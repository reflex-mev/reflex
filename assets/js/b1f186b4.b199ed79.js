"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[15],{1525:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>d,toc:()=>o});var i=r(4848),s=r(8453);const t={sidebar_position:1},l="Smart Contracts API",d={id:"api/smart-contracts",title:"Smart Contracts API",description:"Complete API reference for Reflex smart contracts, covering all functions, events, and data structures.",source:"@site/docs/api/smart-contracts.md",sourceDirName:"api",slug:"/api/smart-contracts",permalink:"/reflex/api/smart-contracts",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/api/smart-contracts.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"SDK Integration",permalink:"/reflex/integration/sdk-integration"},next:{title:"SDK Reference",permalink:"/reflex/api/sdk-reference"}},a={},o=[{value:"\ud83d\udccb Contract Overview",id:"-contract-overview",level:2},{value:"\ud83c\udfaf ReflexRouter",id:"-reflexrouter",level:2},{value:"Constructor",id:"constructor",level:3},{value:"State Variables",id:"state-variables",level:3},{value:"Core Functions",id:"core-functions",level:3},{value:"triggerBackrun",id:"triggerbackrun",level:4},{value:"backrunedExecute",id:"backrunedexecute",level:4},{value:"Administrative Functions",id:"administrative-functions",level:3},{value:"setReflexQuoter",id:"setreflexquoter",level:4},{value:"getReflexAdmin",id:"getreflexadmin",level:4},{value:"withdrawToken",id:"withdrawtoken",level:4},{value:"withdrawEth",id:"withdraweth",level:4},{value:"Internal Functions",id:"internal-functions",level:3},{value:"decodeIsZeroForOne",id:"decodeiszeroforone",level:4},{value:"Events",id:"events",level:3},{value:"BackrunExecuted",id:"backrunexecuted",level:4},{value:"\ud83d\udca1 ReflexQuoter",id:"-reflexquoter",level:2},{value:"Core Functions",id:"core-functions-1",level:3},{value:"getQuote",id:"getquote",level:4},{value:"Data Structures",id:"data-structures",level:3},{value:"SwapDecodedData",id:"swapdecodeddata",level:4},{value:"\ud83d\udcb0 ConfigurableRevenueDistributor",id:"-configurablerevenuedistributor",level:2},{value:"Core Functions",id:"core-functions-2",level:3},{value:"updateShares",id:"updateshares",level:4},{value:"getConfig",id:"getconfig",level:4},{value:"getRecipients",id:"getrecipients",level:4},{value:"Events",id:"events-1",level:3},{value:"SharesUpdated",id:"sharesupdated",level:4},{value:"SplitExecuted",id:"splitexecuted",level:4},{value:"\ud83d\udd0c ReflexAfterSwap (Base Plugin)",id:"-reflexafterswap-base-plugin",level:2},{value:"Constructor",id:"constructor-1",level:3},{value:"State Variables",id:"state-variables-1",level:3},{value:"Administrative Functions",id:"administrative-functions-1",level:3},{value:"setReflexRouter",id:"setreflexrouter",level:4},{value:"setReflexConfigId",id:"setreflexconfigid",level:4},{value:"View Functions",id:"view-functions",level:3},{value:"getRouter",id:"getrouter",level:4},{value:"getReflexAdmin",id:"getreflexadmin-1",level:4},{value:"getConfigId",id:"getconfigid",level:4},{value:"Internal Functions",id:"internal-functions-1",level:3},{value:"reflexAfterSwap",id:"reflexafterswap",level:4},{value:"Modifiers",id:"modifiers",level:3},{value:"onlyReflexAdmin",id:"onlyreflexadmin",level:4},{value:"Implementation Example",id:"implementation-example",level:3},{value:"Error Messages",id:"error-messages",level:2},{value:"ReflexRouter Error Messages",id:"reflexrouter-error-messages",level:3},{value:"ConfigurableRevenueDistributor Error Messages",id:"configurablerevenuedistributor-error-messages",level:3},{value:"ReflexAfterSwap Error Messages",id:"reflexafterswap-error-messages",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"smart-contracts-api",children:"Smart Contracts API"})}),"\n",(0,i.jsx)(n.p,{children:"Complete API reference for Reflex smart contracts, covering all functions, events, and data structures."}),"\n",(0,i.jsx)(n.h2,{id:"-contract-overview",children:"\ud83d\udccb Contract Overview"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Contract"}),(0,i.jsx)(n.th,{children:"Address"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ReflexRouter"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0x742d..."})}),(0,i.jsx)(n.td,{children:"Main router for MEV capture and execution"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ReflexQuoter"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0x9E54..."})}),(0,i.jsx)(n.td,{children:"Price quoter and route optimizer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ConfigurableRevenueDistributor"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0x1A2B..."})}),(0,i.jsx)(n.td,{children:"Revenue sharing management"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"-reflexrouter",children:"\ud83c\udfaf ReflexRouter"}),"\n",(0,i.jsx)(n.p,{children:"The core contract that orchestrates MEV capture and execution."}),"\n",(0,i.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"constructor()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Sets the deployer (",(0,i.jsx)(n.code,{children:"tx.origin"}),") as the contract owner."]}),"\n",(0,i.jsx)(n.h3,{id:"state-variables",children:"State Variables"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"address public owner;\naddress public reflexQuoter;\nuint8 private loanCallbackType;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"core-functions",children:"Core Functions"}),"\n",(0,i.jsx)(n.h4,{id:"triggerbackrun",children:"triggerBackrun"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function triggerBackrun(\n    bytes32 triggerPoolId,\n    uint112 swapAmountIn,\n    bool token0In,\n    address recipient,\n    bytes32 configId\n) external override gracefulNonReentrant\n  returns (uint256 profit, address profitToken)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Executes a backrun arbitrage opportunity."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"triggerPoolId"})," - Unique identifier of the triggering pool (cast from pool address)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"swapAmountIn"})," - Amount of tokens for arbitrage swap (uint112 for gas optimization)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"token0In"})," - Whether to use token0 (true) or token1 (false) as input token"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recipient"})," - Address to receive arbitrage profit (used as dust recipient)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"configId"})," - Configuration ID for profit splitting (uses default if ",(0,i.jsx)(n.code,{children:"bytes32(0)"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profit"})," - Amount of profit generated from the arbitrage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profitToken"})," - Address of the token in which profit was generated"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Events Emitted:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"BackrunExecuted(triggerPoolId, swapAmountIn, token0In, profit, profitToken, recipient)"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"uint256 profit, address profitToken = reflexRouter.triggerBackrun(\n    bytes32(uint256(uint160(poolAddress))),\n    1000000, // 1 USDC (6 decimals)\n    true,    // Use token0 as input\n    msg.sender,\n    bytes32(0) // Use default config\n);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"backrunedexecute",children:"backrunedExecute"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function backrunedExecute(\n    ExecuteParams calldata executeParams,\n    BackrunParams[] calldata backrunParams\n) external payable override gracefulNonReentrant\n  returns (\n    bool success,\n    bytes memory returnData,\n    uint256[] memory profits,\n    address[] memory profitTokens\n  )\n"})}),"\n",(0,i.jsx)(n.p,{children:"Executes arbitrary calldata and then triggers multiple backruns with failsafe mechanisms."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct ExecuteParams {\n    address target;   // Target contract to call\n    uint256 value;    // ETH value to send\n    bytes callData;   // Encoded function call\n}\n\nstruct BackrunParams {\n    bytes32 triggerPoolId;\n    uint112 swapAmountIn;\n    bool token0In;\n    address recipient;\n    bytes32 configId;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"success"})," - Whether the initial call succeeded"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"returnData"})," - Return data from the initial call"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profits"})," - Array of profits from each backrun (0 if failed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profitTokens"})," - Array of profit tokens (address(0) if failed)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Atomic execution with rollback protection"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Individual backrun failure isolation"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Batch profit optimization"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 ETH value forwarding support"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"administrative-functions",children:"Administrative Functions"}),"\n",(0,i.jsx)(n.h4,{id:"setreflexquoter",children:"setReflexQuoter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function setReflexQuoter(address _reflexQuoter) public isAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Sets the ReflexQuoter contract address."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Admin only"]}),"\n",(0,i.jsx)(n.h4,{id:"getreflexadmin",children:"getReflexAdmin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getReflexAdmin() public view returns (address)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the contract admin address."}),"\n",(0,i.jsx)(n.h4,{id:"withdrawtoken",children:"withdrawToken"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function withdrawToken(address token, uint256 amount, address _to) public isAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Withdraws ERC20 tokens from the contract."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Admin only"]}),"\n",(0,i.jsx)(n.h4,{id:"withdraweth",children:"withdrawEth"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function withdrawEth(uint256 amount, address payable _to) public isAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Withdraws ETH from the contract."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Admin only"]}),"\n",(0,i.jsx)(n.h3,{id:"internal-functions",children:"Internal Functions"}),"\n",(0,i.jsx)(n.h4,{id:"decodeiszeroforone",children:"decodeIsZeroForOne"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function decodeIsZeroForOne(uint256 b) public pure returns (bool zeroForOne)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Decodes swap direction from metadata byte using bitwise operations."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// 1 byte - <1 bit zeroForOne><7 bits other data>\nfunction decodeIsZeroForOne(uint256 b) public pure returns (bool zeroForOne) {\n    assembly {\n        zeroForOne := and(b, 0x80)\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.h4,{id:"backrunexecuted",children:"BackrunExecuted"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event BackrunExecuted(\n    bytes32 indexed triggerPoolId,\n    uint112 swapAmountIn,\n    bool token0In,\n    uint256 profit,\n    address profitToken,\n    address recipient\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Emitted when a backrun is successfully executed."}),"\n",(0,i.jsx)(n.h2,{id:"-reflexquoter",children:"\ud83d\udca1 ReflexQuoter"}),"\n",(0,i.jsx)(n.p,{children:"Interface for the price quoter and route optimizer."}),"\n",(0,i.jsx)(n.h3,{id:"core-functions-1",children:"Core Functions"}),"\n",(0,i.jsx)(n.h4,{id:"getquote",children:"getQuote"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getQuote(\n    address triggerPool,\n    uint8 tokenInIndex,\n    uint256 amountIn\n) external view returns (\n    uint256 profit,\n    SwapDecodedData memory decoded,\n    uint256[] memory amountsOut,\n    uint256 initialHopIndex\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Analyzes arbitrage opportunities and returns optimal execution parameters."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"triggerPool"})," - Address of the pool that triggered the opportunity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tokenInIndex"})," - Index of input token (0 for token0, 1 for token1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amountIn"})," - Amount of input tokens for the arbitrage"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profit"})," - Estimated profit from the arbitrage (0 if not profitable)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"decoded"})," - Swap route data structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amountsOut"})," - Token amounts for each hop in the route"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"initialHopIndex"})," - Starting index for the swap route"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"data-structures",children:"Data Structures"}),"\n",(0,i.jsx)(n.h4,{id:"swapdecodeddata",children:"SwapDecodedData"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct SwapDecodedData {\n    address[] pools;     // Array of pool addresses in the route\n    uint8[] dexType;     // DEX type for each pool (UniV2, UniV3, etc.)\n    uint8[] dexMeta;     // Metadata for each pool (swap direction, etc.)\n    address[] tokens;    // Token addresses involved in the route\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"DEX Types:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"1"})," - UniswapV2 (with callback)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"2"})," - UniswapV2 (without callback)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"3"})," - UniswapV3"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"6"})," - Algebra (Quickswap)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-configurablerevenuedistributor",children:"\ud83d\udcb0 ConfigurableRevenueDistributor"}),"\n",(0,i.jsx)(n.p,{children:"Manages profit distribution across multiple stakeholders."}),"\n",(0,i.jsx)(n.h3,{id:"core-functions-2",children:"Core Functions"}),"\n",(0,i.jsx)(n.h4,{id:"updateshares",children:"updateShares"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function updateShares(\n    bytes32 configId,\n    address[] calldata recipients,\n    uint256[] calldata sharesBps,\n    uint256 dustShareBps\n) external\n"})}),"\n",(0,i.jsx)(n.p,{children:"Configures profit distribution for a specific configuration ID using basis points."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"configId"})," - Unique identifier for the configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recipients"})," - Array of recipient addresses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"sharesBps"})," - Array of share amounts in basis points (1% = 100 bps)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dustShareBps"})," - Dust recipient's share in basis points"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Recipients and shares arrays must have equal length"}),"\n",(0,i.jsx)(n.li,{children:"All recipients must be non-zero addresses"}),"\n",(0,i.jsx)(n.li,{children:"All shares must be greater than 0"}),"\n",(0,i.jsx)(n.li,{children:"Total shares (including dust) must equal 10,000 bps (100%)"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getconfig",children:"getConfig"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getConfig(bytes32 configId)\n    external view returns (SplitConfig memory config)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Retrieves the complete revenue configuration for a given ID."}),"\n",(0,i.jsx)(n.h4,{id:"getrecipients",children:"getRecipients"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getRecipients(bytes32 configId)\n    external view returns (\n        address[] memory recipients,\n        uint256[] memory sharesBps,\n        uint256 dustShareBps\n    )\n"})}),"\n",(0,i.jsx)(n.p,{children:"Retrieves the revenue configuration details for a given ID."}),"\n",(0,i.jsx)(n.h3,{id:"events-1",children:"Events"}),"\n",(0,i.jsx)(n.h4,{id:"sharesupdated",children:"SharesUpdated"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event SharesUpdated(\n    bytes32 indexed configId,\n    address[] recipients,\n    uint256[] sharesBps,\n    uint256 dustShareBps\n);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"splitexecuted",children:"SplitExecuted"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event SplitExecuted(\n    bytes32 indexed configId,\n    address indexed token,\n    uint256 totalAmount,\n    address[] recipients,\n    uint256[] amounts,\n    address dustRecipient,\n    uint256 dustAmount\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Emitted when revenue is successfully distributed."}),"\n",(0,i.jsx)(n.h2,{id:"-reflexafterswap-base-plugin",children:"\ud83d\udd0c ReflexAfterSwap (Base Plugin)"}),"\n",(0,i.jsx)(n.p,{children:"Abstract base contract for DEX plugin integration with failsafe mechanisms."}),"\n",(0,i.jsx)(n.h3,{id:"constructor-1",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"constructor(address _router, bytes32 _configId)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_router"})," - Address of the ReflexRouter contract"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_configId"})," - Configuration ID for profit distribution"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Validation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Router address must be non-zero"}),"\n",(0,i.jsx)(n.li,{children:"Fetches admin address from the router contract"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"state-variables-1",children:"State Variables"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"address reflexRouter;      // Address of the Reflex router contract\naddress reflexAdmin;       // Address of the reflex admin (authorized controller)\nbytes32 reflexConfigId;    // Configuration ID for profit distribution\n"})}),"\n",(0,i.jsx)(n.h3,{id:"administrative-functions-1",children:"Administrative Functions"}),"\n",(0,i.jsx)(n.h4,{id:"setreflexrouter",children:"setReflexRouter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function setReflexRouter(address _router) external onlyReflexAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Updates the Reflex router address and refreshes admin."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_router"})," - New router address to set"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Reflex admin only"]}),"\n",(0,i.jsx)(n.h4,{id:"setreflexconfigid",children:"setReflexConfigId"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function setReflexConfigId(bytes32 _configId) external onlyReflexAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Updates the configuration ID for profit distribution."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_configId"})," - New configuration ID to set"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Reflex admin only"]}),"\n",(0,i.jsx)(n.h3,{id:"view-functions",children:"View Functions"}),"\n",(0,i.jsx)(n.h4,{id:"getrouter",children:"getRouter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getRouter() public view returns (address)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the current router address."}),"\n",(0,i.jsx)(n.h4,{id:"getreflexadmin-1",children:"getReflexAdmin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getReflexAdmin() external view returns (address)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the current reflex admin address."}),"\n",(0,i.jsx)(n.h4,{id:"getconfigid",children:"getConfigId"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getConfigId() external view returns (bytes32)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the current configuration ID for profit distribution."}),"\n",(0,i.jsx)(n.h3,{id:"internal-functions-1",children:"Internal Functions"}),"\n",(0,i.jsx)(n.h4,{id:"reflexafterswap",children:"reflexAfterSwap"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function reflexAfterSwap(\n    bytes32 triggerPoolId,\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bool zeroForOne,\n    address recipient\n) internal gracefulNonReentrant returns (uint256 profit, address profitToken)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Main entry point for post-swap profit extraction via backrunning."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"triggerPoolId"})," - Unique identifier for the pool that triggered the swap"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amount0Delta"})," - The change in token0 balance from the original swap"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amount1Delta"})," - The change in token1 balance from the original swap"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"zeroForOne"})," - Direction of the original swap (true if token0 \u2192 token1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recipient"})," - Address that should receive the extracted profits"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profit"})," - Amount of profit extracted (0 if router call fails)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profitToken"})," - Address of the token in which profit was extracted (address(0) if failed)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Failsafe operation with try-catch mechanism"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Router failures won't break main swap operations"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Reentrancy protection via graceful reentrancy guard"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Automatic profit distribution using configured settings"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"modifiers",children:"Modifiers"}),"\n",(0,i.jsx)(n.h4,{id:"onlyreflexadmin",children:"onlyReflexAdmin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'modifier onlyReflexAdmin() {\n    require(msg.sender == reflexAdmin, "Caller is not the reflex admin");\n    _;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Restricts access to reflex admin only."}),"\n",(0,i.jsx)(n.h3,{id:"implementation-example",children:"Implementation Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.20;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract UniswapV3Plugin is ReflexAfterSwap {\n    address public immutable pool;\n    uint256 public constant MIN_BACKRUN_THRESHOLD = 1000e6; // 1000 USDC minimum\n\n    constructor(\n        address _reflexRouter,\n        address _pool,\n        bytes32 _configId\n    ) ReflexAfterSwap(_reflexRouter, _configId) {\n        pool = _pool;\n    }\n\n    modifier onlyPool() {\n        require(msg.sender == pool, "Only pool can call");\n        _;\n    }\n\n    // This would be called by the Uniswap V3 pool after each swap\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external onlyPool {\n        // Extract swap information\n        uint256 swapAmount = uint256(amount0Delta > 0 ? amount0Delta : -amount0Delta);\n        if (amount1Delta < 0) {\n            swapAmount = uint256(-amount1Delta);\n        }\n\n        // Only trigger backrun for significant swaps\n        if (swapAmount >= MIN_BACKRUN_THRESHOLD) {\n            // Determine swap direction\n            bool zeroForOne = amount0Delta > 0;\n\n            // Extract recipient from callback data (implementation specific)\n            address recipient = abi.decode(data, (address));\n\n            // Trigger backrun using ReflexAfterSwap\'s internal function\n            (uint256 profit, address profitToken) = reflexAfterSwap(\n                bytes32(uint256(uint160(pool))), // Pool ID from pool address\n                amount0Delta,\n                amount1Delta,\n                zeroForOne,\n                recipient\n            );\n\n            // Emit event if profit was extracted\n            if (profit > 0) {\n                emit BackrunExecuted(recipient, profit, profitToken);\n            }\n        }\n    }\n\n    // Admin function to update configuration\n    function updateConfig(bytes32 newConfigId) external {\n        // This will call ReflexAfterSwap\'s setReflexConfigId with admin check\n        setReflexConfigId(newConfigId);\n    }\n\n    event BackrunExecuted(\n        address indexed recipient,\n        uint256 profit,\n        address profitToken\n    );\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-messages",children:"Error Messages"}),"\n",(0,i.jsx)(n.h3,{id:"reflexrouter-error-messages",children:"ReflexRouter Error Messages"}),"\n",(0,i.jsxs)(n.p,{children:["The ReflexRouter uses ",(0,i.jsx)(n.code,{children:"require"})," statements with descriptive error messages:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Only admin can manage revenue configurations"'})," - Access control for admin functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Only self-call allowed"'})," - Internal function access restriction"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Initial call failed"'})," - When the executed call in ",(0,i.jsx)(n.code,{children:"backrunedExecute"})," fails"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"configurablerevenuedistributor-error-messages",children:"ConfigurableRevenueDistributor Error Messages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"ETH transfer failed"'})," - ETH transfer to recipient failed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"ETH dust transfer failed"'})," - ETH dust transfer failed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Recipients and shares length mismatch"'})," - Array length mismatch"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"No recipients provided"'})," - Empty recipients array"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Invalid recipient address"'})," - Zero address recipient"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Invalid share amount"'})," - Zero share amount"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Total shares must equal 100%"'})," - Share distribution doesn't sum to 10,000 bps"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"reflexafterswap-error-messages",children:"ReflexAfterSwap Error Messages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Invalid router address"'})," - Router address is zero in constructor or setReflexRouter"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'"Caller is not the reflex admin"'})," - Access control for admin-only functions"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);