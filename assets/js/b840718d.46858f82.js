"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[8985],{3347:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=t(4848),s=t(8453);const i={sidebar_position:3},a="SDK Integration",o={id:"technical/integration/sdk-integration",title:"SDK Integration",description:"Integrate Reflex MEV capture into your client applications, DApps, and custom trading strategies using the TypeScript SDK.",source:"@site/docs/technical/integration/sdk-integration.md",sourceDirName:"technical/integration",slug:"/technical/integration/sdk-integration",permalink:"/reflex/technical/integration/sdk-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/technical/integration/sdk-integration.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Smart Contract Integration",permalink:"/reflex/technical/integration/smart-contract"},next:{title:"Basic Backrun Example",permalink:"/reflex/technical/examples/basic-backrun"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Installation",id:"installation",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"Monitor and Execute MEV",id:"monitor-and-execute-mev",level:3},{value:"DApp Integration",id:"dapp-integration",level:2},{value:"Frontend Integration",id:"frontend-integration",level:3},{value:"Trading Interface Component",id:"trading-interface-component",level:3},{value:"Advanced Trading Strategies",id:"advanced-trading-strategies",level:2},{value:"Arbitrage Bot",id:"arbitrage-bot",level:3},{value:"MEV Protection for Users",id:"mev-protection-for-users",level:3},{value:"Configuration and Optimization",id:"configuration-and-optimization",level:2},{value:"Gas Management",id:"gas-management",level:3},{value:"Event Monitoring",id:"event-monitoring",level:3},{value:"Testing",id:"testing",level:2},{value:"Mock Environment",id:"mock-environment",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Performance",id:"performance",level:3},{value:"Security",id:"security",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sdk-integration",children:"SDK Integration"})}),"\n",(0,r.jsx)(n.p,{children:"Integrate Reflex MEV capture into your client applications, DApps, and custom trading strategies using the TypeScript SDK."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Reflex SDK provides a powerful and easy-to-use interface for building MEV-enabled applications. Whether you're building a trading bot, integrating MEV capture into a DApp frontend, or creating custom arbitrage strategies, the SDK handles the complexity of interacting with Reflex smart contracts."}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @reflex/sdk ethers\n# or\nyarn add @reflex/sdk ethers\n"})}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { ReflexSDK } from '@reflex/sdk';\nimport { ethers } from 'ethers';\n\n// Initialize provider and signer\nconst provider = new ethers.JsonRpcProvider('https://mainnet.infura.io/v3/YOUR_KEY');\nconst signer = new ethers.Wallet('YOUR_PRIVATE_KEY', provider);\n\n// Create SDK instance\nconst reflex = new ReflexSDK({\n    provider,\n    signer,\n    chainId: 1, // Mainnet\n    options: {\n        gasLimit: 300000,\n        slippageTolerance: 0.005, // 0.5%\n    }\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"monitor-and-execute-mev",children:"Monitor and Execute MEV"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Start monitoring for MEV opportunities\nasync function startMEVBot() {\n    console.log('Starting MEV monitoring...');\n    \n    // Listen for swap events across multiple pools\n    const pools = [\n        '0xPool1Address',\n        '0xPool2Address',\n        '0xPool3Address'\n    ];\n    \n    for (const poolAddress of pools) {\n        const poolContract = new ethers.Contract(poolAddress, POOL_ABI, provider);\n        \n        poolContract.on('Swap', async (sender, amount0In, amount1In, amount0Out, amount1Out, event) => {\n            const swapAmount = amount0In > 0n ? amount0In : amount1In;\n            \n            // Only process significant swaps\n            if (swapAmount > ethers.parseEther('1')) {\n                await processMEVOpportunity({\n                    poolAddress,\n                    swapAmount,\n                    token0In: amount0In > 0n,\n                    originalSwapper: sender,\n                    txHash: event.transactionHash\n                });\n            }\n        });\n    }\n}\n\nasync function processMEVOpportunity(opportunity) {\n    try {\n        // Check if opportunity is still profitable\n        const quote = await reflex.getQuote({\n            triggerPoolId: opportunity.poolAddress,\n            swapAmountIn: opportunity.swapAmount / 10n, // Use 10% for backrun\n            token0In: opportunity.token0In,\n        });\n        \n        if (quote.expectedProfit > ethers.parseEther('0.01')) {\n            console.log('Executing MEV opportunity:', {\n                pool: opportunity.poolAddress,\n                expectedProfit: ethers.formatEther(quote.expectedProfit)\n            });\n            \n            // Execute the backrun\n            const result = await reflex.triggerBackrun({\n                triggerPoolId: opportunity.poolAddress,\n                swapAmountIn: opportunity.swapAmount / 10n,\n                token0In: opportunity.token0In,\n                recipient: opportunity.originalSwapper, // Share profit with user\n                configId: ethers.ZeroHash, // Use default config\n            });\n            \n            if (result.success) {\n                console.log('MEV captured successfully:', {\n                    txHash: result.txHash,\n                    profit: ethers.formatEther(result.profit),\n                    gasUsed: result.gasUsed.toString()\n                });\n            }\n        }\n    } catch (error) {\n        console.error('MEV opportunity failed:', error.message);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"dapp-integration",children:"DApp Integration"}),"\n",(0,r.jsx)(n.h3,{id:"frontend-integration",children:"Frontend Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// React hook for MEV integration\nimport { useState, useEffect, useCallback } from 'react';\nimport { ReflexSDK } from '@reflex/sdk';\n\nexport function useReflexMEV(provider, signer) {\n    const [reflex, setReflex] = useState(null);\n    const [mevStats, setMevStats] = useState({\n        totalCaptured: 0n,\n        userRewards: 0n,\n        successRate: 0\n    });\n    \n    useEffect(() => {\n        if (provider && signer) {\n            const reflexInstance = new ReflexSDK({\n                provider,\n                signer,\n                chainId: 1,\n            });\n            \n            setReflex(reflexInstance);\n            \n            // Listen for MEV events\n            reflexInstance.on('BackrunExecuted', (event) => {\n                setMevStats(prev => ({\n                    ...prev,\n                    totalCaptured: prev.totalCaptured + event.profit,\n                    userRewards: prev.userRewards + (event.profit * 3n / 10n) // 30% to users\n                }));\n            });\n        }\n    }, [provider, signer]);\n    \n    const executeSwapWithMEV = useCallback(async (swapParams) => {\n        if (!reflex) return null;\n        \n        try {\n            // Execute the user's swap first\n            const swapTx = await executeUserSwap(swapParams);\n            await swapTx.wait();\n            \n            // Then trigger MEV capture\n            const mevResult = await reflex.triggerBackrun({\n                triggerPoolId: swapParams.poolAddress,\n                swapAmountIn: swapParams.amountIn / 20n, // 5% of swap\n                token0In: swapParams.token0In,\n                recipient: swapParams.user,\n                configId: swapParams.configId || ethers.ZeroHash,\n            });\n            \n            return {\n                swapTx,\n                mevResult,\n                totalProfit: mevResult.profit\n            };\n        } catch (error) {\n            console.error('Swap with MEV failed:', error);\n            throw error;\n        }\n    }, [reflex]);\n    \n    return {\n        reflex,\n        mevStats,\n        executeSwapWithMEV,\n        isReady: !!reflex\n    };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"trading-interface-component",children:"Trading Interface Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// MEV-enabled trading component\nimport React, { useState } from 'react';\n\nexport function MEVTradingInterface({ useReflexMEV }) {\n    const { executeSwapWithMEV, mevStats, isReady } = useReflexMEV(provider, signer);\n    const [swapAmount, setSwapAmount] = useState('');\n    const [isSwapping, setIsSwapping] = useState(false);\n    \n    const handleSwap = async () => {\n        setIsSwapping(true);\n        \n        try {\n            const result = await executeSwapWithMEV({\n                tokenIn: selectedTokenIn.address,\n                tokenOut: selectedTokenOut.address,\n                amountIn: ethers.parseEther(swapAmount),\n                poolAddress: poolAddress,\n                user: userAddress,\n                token0In: selectedTokenIn.address < selectedTokenOut.address\n            });\n            \n            if (result.mevResult.success) {\n                showNotification({\n                    type: 'success',\n                    title: 'Swap Completed with MEV Bonus!',\n                    message: `You received an additional ${ethers.formatEther(result.totalProfit)} ETH from MEV capture`\n                });\n            }\n        } catch (error) {\n            showNotification({\n                type: 'error',\n                title: 'Swap Failed',\n                message: error.message\n            });\n        } finally {\n            setIsSwapping(false);\n        }\n    };\n    \n    return (\n        <div className=\"trading-interface\">\n            {/* MEV Stats Display */}\n            <div className=\"mev-stats\">\n                <h3>MEV Benefits</h3>\n                <div>Total Captured: {ethers.formatEther(mevStats.totalCaptured)} ETH</div>\n                <div>Your Rewards: {ethers.formatEther(mevStats.userRewards)} ETH</div>\n                <div>Success Rate: {(mevStats.successRate * 100).toFixed(1)}%</div>\n            </div>\n            \n            {/* Trading Interface */}\n            <div className=\"swap-form\">\n                <input\n                    type=\"number\"\n                    value={swapAmount}\n                    onChange={(e) => setSwapAmount(e.target.value)}\n                    placeholder=\"Amount to swap\"\n                />\n                \n                <button\n                    onClick={handleSwap}\n                    disabled={!isReady || isSwapping}\n                    className=\"swap-button\"\n                >\n                    {isSwapping ? 'Swapping...' : 'Swap with MEV Protection'}\n                </button>\n            </div>\n        </div>\n    );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-trading-strategies",children:"Advanced Trading Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"arbitrage-bot",children:"Arbitrage Bot"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class ReflexArbitrageBot {\n    private reflex: ReflexSDK;\n    private pools: string[];\n    private isRunning = false;\n    \n    constructor(config: BotConfig) {\n        this.reflex = new ReflexSDK(config.sdkConfig);\n        this.pools = config.monitoredPools;\n    }\n    \n    async start() {\n        this.isRunning = true;\n        console.log('Starting arbitrage bot...');\n        \n        // Monitor multiple pools simultaneously\n        await Promise.all(\n            this.pools.map(poolAddress => this.monitorPool(poolAddress))\n        );\n    }\n    \n    private async monitorPool(poolAddress: string) {\n        const poolContract = new ethers.Contract(poolAddress, POOL_ABI, this.reflex.provider);\n        \n        poolContract.on('Swap', async (sender, ...args) => {\n            if (!this.isRunning) return;\n            \n            // Quick profitability check\n            const opportunity = await this.analyzeOpportunity(poolAddress, args);\n            \n            if (opportunity.profitable) {\n                await this.executeArbitrage(opportunity);\n            }\n        });\n    }\n    \n    private async analyzeOpportunity(poolAddress: string, swapData: any) {\n        // Calculate potential arbitrage across multiple DEXs\n        const quotes = await Promise.all([\n            this.reflex.getQuote({ /* params for DEX A */ }),\n            this.getExternalQuote('uniswap', /* params */),\n            this.getExternalQuote('sushiswap', /* params */),\n        ]);\n        \n        // Find best arbitrage route\n        const bestRoute = this.findBestArbitrageRoute(quotes);\n        \n        return {\n            profitable: bestRoute.profit > ethers.parseEther('0.02'),\n            route: bestRoute,\n            poolAddress,\n            estimatedGas: bestRoute.gasEstimate\n        };\n    }\n    \n    private async executeArbitrage(opportunity) {\n        try {\n            // Execute multi-hop arbitrage using Reflex\n            const result = await this.reflex.executeComplexArbitrage({\n                route: opportunity.route,\n                maxGasPrice: ethers.parseUnits('50', 'gwei'),\n                deadline: Math.floor(Date.now() / 1000) + 300 // 5 minutes\n            });\n            \n            console.log('Arbitrage executed:', {\n                profit: ethers.formatEther(result.profit),\n                gasUsed: result.gasUsed.toString(),\n                route: opportunity.route.path\n            });\n        } catch (error) {\n            console.error('Arbitrage failed:', error);\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"mev-protection-for-users",children:"MEV Protection for Users"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Protect users from sandwich attacks\nclass MEVProtectionService {\n    private reflex: ReflexSDK;\n    \n    constructor(config: ReflexSDKConfig) {\n        this.reflex = new ReflexSDK(config);\n    }\n    \n    async protectedSwap(swapParams: SwapParams) {\n        // 1. Pre-analyze for sandwich risk\n        const riskAnalysis = await this.analyzeSandwichRisk(swapParams);\n        \n        if (riskAnalysis.highRisk) {\n            // 2. Use Reflex to preemptively capture MEV\n            await this.preemptiveMEVCapture(swapParams);\n        }\n        \n        // 3. Execute user swap\n        const swapResult = await this.executeSwap(swapParams);\n        \n        // 4. Trigger backrun to capture remaining MEV\n        const backrunResult = await this.reflex.triggerBackrun({\n            triggerPoolId: swapParams.poolAddress,\n            swapAmountIn: swapParams.amountIn / 10n,\n            token0In: swapParams.token0In,\n            recipient: swapParams.user,\n            configId: swapParams.configId\n        });\n        \n        return {\n            swapResult,\n            backrunResult,\n            totalMEVCaptured: backrunResult.profit,\n            protectionApplied: riskAnalysis.highRisk\n        };\n    }\n    \n    private async analyzeSandwichRisk(params: SwapParams) {\n        // Analyze mempool for potential sandwich attacks\n        const pendingTxs = await this.reflex.getPendingTransactions(params.poolAddress);\n        \n        // Check for suspicious patterns\n        const suspiciousTxs = pendingTxs.filter(tx => \n            this.isSuspiciousSandwichSetup(tx, params)\n        );\n        \n        return {\n            highRisk: suspiciousTxs.length > 0,\n            riskScore: this.calculateRiskScore(suspiciousTxs),\n            recommendations: this.generateProtectionRecommendations(suspiciousTxs)\n        };\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-and-optimization",children:"Configuration and Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"gas-management",children:"Gas Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Advanced gas optimization\nconst reflex = new ReflexSDK({\n    provider,\n    signer,\n    chainId: 1,\n    options: {\n        gasStrategy: {\n            type: 'dynamic',\n            priorityFeeMultiplier: 1.1,\n            maxFeePerGasMultiplier: 1.2,\n            gasLimitMultiplier: 1.1\n        },\n        mevSettings: {\n            maxSlippage: 0.005,\n            minProfitThreshold: ethers.parseEther('0.01'),\n            maxGasPrice: ethers.parseUnits('100', 'gwei')\n        }\n    }\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"event-monitoring",children:"Event Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Comprehensive event monitoring\nreflex.on('BackrunExecuted', (event) => {\n    analytics.track('MEV_Captured', {\n        profit: event.profit,\n        pool: event.triggerPoolId,\n        recipient: event.recipient,\n        timestamp: event.timestamp\n    });\n});\n\nreflex.on('BackrunFailed', (event) => {\n    console.warn('MEV capture failed:', event.reason);\n    \n    // Implement retry logic or alerts\n    if (event.reason === 'INSUFFICIENT_PROFIT') {\n        adjustProfitThreshold(event.triggerPoolId);\n    }\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.h3,{id:"mock-environment",children:"Mock Environment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Test your integration\nimport { createMockProvider, createTestWallet } from '@reflex/sdk/testing';\n\ndescribe('MEV Integration', () => {\n    let reflex: ReflexSDK;\n    \n    beforeEach(() => {\n        const provider = createMockProvider();\n        const wallet = createTestWallet();\n        \n        reflex = new ReflexSDK({\n            provider,\n            signer: wallet,\n            chainId: 31337, // Hardhat\n            options: { mockMode: true }\n        });\n    });\n    \n    it('should capture MEV successfully', async () => {\n        const result = await reflex.triggerBackrun({\n            triggerPoolId: '0x123...',\n            swapAmountIn: ethers.parseEther('1'),\n            token0In: true,\n            recipient: '0xUser...',\n            configId: ethers.ZeroHash\n        });\n        \n        expect(result.success).toBe(true);\n        expect(result.profit).toBeGreaterThan(0n);\n    });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Always handle SDK errors gracefully"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Implement retry logic for network issues"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Use try/catch for all async operations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Monitor and log all MEV attempts"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Cache frequently used data"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Use batch operations when possible"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Implement connection pooling"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Monitor gas usage patterns"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"security",children:"Security"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Never expose private keys in frontend code"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Validate all user inputs"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Use secure RPC endpoints"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Implement rate limiting"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["For smart contract integration, see the ",(0,r.jsx)(n.a,{href:"./smart-contract",children:"Smart Contract Integration Guide"}),".\nFor complete examples, check out the ",(0,r.jsx)(n.a,{href:"../examples/basic-backrun",children:"Basic Backrun Example"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);