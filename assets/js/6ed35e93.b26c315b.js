"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[8853],{7395:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>l});var s=r(4848),t=r(8453);const a={sidebar_position:1},i="UniversalIntegration",d={id:"api/sdk/universal-integration",title:"UniversalIntegration",description:"TypeScript SDK for integrating Reflex MEV capture with any DEX using the BackrunEnabledSwapProxy pattern.",source:"@site/docs/api/sdk/universal-integration.md",sourceDirName:"api/sdk",slug:"/api/sdk/universal-integration",permalink:"/reflex/api/sdk/universal-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/api/sdk/universal-integration.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"BackrunEnabledSwapProxy",permalink:"/reflex/api/backrun-enabled-swap-proxy"},next:{title:"Security",permalink:"/reflex/security"}},o={},l=[{value:"Installation",id:"installation",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Methods",id:"methods",level:2},{value:"swapWithBackrun()",id:"swapwithbackrun",level:3},{value:"approveTokens()",id:"approvetokens",level:3},{value:"isTokenApproved()",id:"istokenapproved",level:3},{value:"estimateGas()",id:"estimategas",level:3},{value:"getSwapProxyAddress()",id:"getswapproxyaddress",level:3},{value:"getReflexRouterAddress()",id:"getreflexrouteraddress",level:3},{value:"getTargetRouterAddress()",id:"gettargetrouteraddress",level:3},{value:"Type Definitions",id:"type-definitions",level:2},{value:"SwapMetadata",id:"swapmetadata",level:3},{value:"BackrunParams",id:"backrunparams",level:3},{value:"TokenApproval",id:"tokenapproval",level:3},{value:"SwapWithBackrunResult",id:"swapwithbackrunresult",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Usage Guides",id:"usage-guides",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"universalintegration",children:"UniversalIntegration"})}),"\n",(0,s.jsx)(n.p,{children:"TypeScript SDK for integrating Reflex MEV capture with any DEX using the BackrunEnabledSwapProxy pattern."}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @reflex-mev/sdk ethers\n# or\nyarn add @reflex-mev/sdk ethers\n"})}),"\n",(0,s.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class UniversalIntegration {\n  constructor(\n    provider: ethers.Provider,\n    signer: ethers.Signer,\n    swapProxyAddress: string,\n    reflexRouterAddress: string\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"provider"})," - ethers.js Provider instance for blockchain interaction"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"signer"})," - ethers.js Signer for signing transactions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"swapProxyAddress"})," - Address of deployed BackrunEnabledSwapProxy contract"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reflexRouterAddress"})," - Address of Reflex Router contract"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\nimport { ethers } from "ethers";\n\nconst provider = new ethers.JsonRpcProvider("https://rpc.url");\nconst signer = new ethers.Wallet("PRIVATE_KEY", provider);\n\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  "0xSwapProxyAddress",\n  "0xReflexRouterAddress"\n);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(n.h3,{id:"swapwithbackrun",children:"swapWithBackrun()"}),"\n",(0,s.jsx)(n.p,{children:"Execute a swap through the target DEX with automatic MEV backrun capture."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async swapWithBackrun(\n  swapTxCallData: string,\n  swapMetadata: SwapMetadata,\n  backrunParams: BackrunParams[],\n  overrides?: ethers.Overrides\n): Promise<SwapWithBackrunResult>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"swapTxCallData"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Hex-encoded calldata for the target DEX router call"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"swapMetadata"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"SwapMetadata"})}),(0,s.jsx)(n.td,{children:"Metadata about the swap transaction"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"backrunParams"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"BackrunParams[]"})}),(0,s.jsx)(n.td,{children:"Array of backrun configurations (supports multi-pool backruns)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"overrides"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ethers.Overrides"})}),(0,s.jsx)(n.td,{children:"Optional transaction overrides (gasLimit, maxFeePerGas, etc.)"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Promise<SwapWithBackrunResult>"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const result = await integration.swapWithBackrun(\n  swapCalldata,\n  {\n    swapTxCallData: swapCalldata,\n    tokenIn: "0xTokenInAddress",\n    amountIn: ethers.parseEther("1.0"),\n    tokenOut: "0xTokenOutAddress",\n    recipient: "0xUserAddress"\n  },\n  [\n    {\n      triggerPoolId: "0xPoolAddress",\n      swapAmountIn: ethers.parseEther("1.0"),\n      token0In: true,\n      recipient: "0xUserAddress",\n      configId: ethers.ZeroHash\n    }\n  ],\n  { gasLimit: 1500000n }\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"approvetokens",children:"approveTokens()"}),"\n",(0,s.jsx)(n.p,{children:"Approve tokens for spending by the SwapProxy contract."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async approveTokens(\n  approvals: TokenApproval[]\n): Promise<ethers.TransactionReceipt[]>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"approvals"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"TokenApproval[]"})}),(0,s.jsx)(n.td,{children:"Array of token approvals to execute"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Promise<ethers.TransactionReceipt[]>"})," - Array of approval transaction receipts"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// Approve unlimited\nawait integration.approveTokens([\n  {\n    tokenAddress: "0xUSDC",\n    amount: ethers.MaxUint256\n  }\n]);\n\n// Approve multiple tokens\nawait integration.approveTokens([\n  { tokenAddress: "0xUSDC", amount: ethers.MaxUint256 },\n  { tokenAddress: "0xWETH", amount: ethers.MaxUint256 }\n]);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"istokenapproved",children:"isTokenApproved()"}),"\n",(0,s.jsx)(n.p,{children:"Check if a token has sufficient approval for the SwapProxy."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async isTokenApproved(\n  tokenAddress: string,\n  amount: bigint\n): Promise<boolean>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"tokenAddress"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"Address of the token to check"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"amount"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bigint"})}),(0,s.jsx)(n.td,{children:"Amount to check approval for"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Promise<boolean>"})," - true if approved for at least the specified amount"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const isApproved = await integration.isTokenApproved(\n  "0xUSDC",\n  ethers.parseUnits("100", 6)\n);\n\nif (!isApproved) {\n  await integration.approveTokens([\n    { tokenAddress: "0xUSDC", amount: ethers.MaxUint256 }\n  ]);\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"estimategas",children:"estimateGas()"}),"\n",(0,s.jsx)(n.p,{children:"Estimate gas required for a swap with backrun operation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async estimateGas(\n  swapTxCallData: string,\n  swapMetadata: SwapMetadata,\n  backrunParams: BackrunParams[]\n): Promise<bigint>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"})," Same as ",(0,s.jsx)(n.code,{children:"swapWithBackrun()"})," (minus overrides)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Promise<bigint>"})," - Estimated gas with 20% buffer included"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const estimatedGas = await integration.estimateGas(\n  swapCalldata,\n  swapMetadata,\n  backrunParams\n);\n\nconsole.log("Estimated gas:", estimatedGas.toString());\n\n// Use estimate in transaction\nawait integration.swapWithBackrun(\n  swapCalldata,\n  swapMetadata,\n  backrunParams,\n  { gasLimit: estimatedGas }\n);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"getswapproxyaddress",children:"getSwapProxyAddress()"}),"\n",(0,s.jsx)(n.p,{children:"Get the SwapProxy contract address."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"getSwapProxyAddress(): string\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"string"})," - Address of the BackrunEnabledSwapProxy contract"]}),"\n",(0,s.jsx)(n.h3,{id:"getreflexrouteraddress",children:"getReflexRouterAddress()"}),"\n",(0,s.jsx)(n.p,{children:"Get the ReflexRouter contract address."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"getReflexRouterAddress(): string\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"string"})," - Address of the ReflexRouter contract"]}),"\n",(0,s.jsx)(n.h3,{id:"gettargetrouteraddress",children:"getTargetRouterAddress()"}),"\n",(0,s.jsx)(n.p,{children:"Get the target DEX router address from the SwapProxy."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async getTargetRouterAddress(): Promise<string>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"Promise<string>"})," - Address of the target DEX router"]}),"\n",(0,s.jsx)(n.h2,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,s.jsx)(n.h3,{id:"swapmetadata",children:"SwapMetadata"}),"\n",(0,s.jsx)(n.p,{children:"Metadata about the swap transaction."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface SwapMetadata {\n  swapTxCallData: string;  // Hex-encoded calldata for DEX router\n  tokenIn: string;          // Address of input token\n  amountIn: bigint;         // Amount of input token (full swap amount)\n  tokenOut: string;         // Address of output token\n  recipient: string;        // Address to receive swap output and MEV profits\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field Details:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"swapTxCallData"})," - Must be valid calldata for the target DEX router"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tokenIn"})," - ERC20 token address or zero address for ETH"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"amountIn"})," - Full swap amount (backrun sizing handled by Router based on configId)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tokenOut"})," - ERC20 token address or zero address for ETH"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"recipient"})," - Receives both swap output tokens and any MEV profits"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"backrunparams",children:"BackrunParams"}),"\n",(0,s.jsx)(n.p,{children:"Configuration for a single backrun operation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface BackrunParams {\n  triggerPoolId: string;   // Address of the pool being traded on\n  swapAmountIn: bigint;    // Full swap amount (same as SwapMetadata.amountIn)\n  token0In: boolean;       // Swap direction (true = token0\u2192token1, false = token1\u2192token0)\n  recipient: string;       // Address to receive MEV profits\n  configId: string;        // Configuration ID (use ethers.ZeroHash for default)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field Details:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"triggerPoolId"})," - Pool address that the swap trades through"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"swapAmountIn"})," - Always the full swap amount; Router handles backrun sizing internally"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"token0In"})," - Determined by token address comparison (tokenIn < tokenOut = true)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"recipient"})," - Can differ from swap recipient for profit routing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configId"})," - Hash identifying backrun configuration (default = ethers.ZeroHash)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tokenapproval",children:"TokenApproval"}),"\n",(0,s.jsx)(n.p,{children:"Token approval parameters."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface TokenApproval {\n  tokenAddress: string;  // Address of token to approve\n  amount: bigint;        // Amount to approve\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"swapwithbackrunresult",children:"SwapWithBackrunResult"}),"\n",(0,s.jsx)(n.p,{children:"Result of a swap with backrun operation."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface SwapWithBackrunResult {\n  transactionHash: string;     // Transaction hash\n  blockNumber: number;         // Block number where tx was mined\n  gasUsed: bigint;            // Actual gas used\n  swapReturnData: string;     // Return data from DEX swap call\n  profits: bigint[];          // MEV profits captured (one per backrun)\n  profitTokens: string[];     // Token addresses for each profit\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Field Details:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transactionHash"})," - Use for block explorer links and tracking"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"blockNumber"})," - Useful for event filtering and confirmations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gasUsed"})," - Actual gas consumed (for analytics)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"swapReturnData"})," - Raw return data from the DEX router call"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"profits"})," - Array of profit amounts (indexed by BackrunParams order)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"profitTokens"})," - Array of token addresses for each profit"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\nimport { ethers } from "ethers";\n\n// Initialize provider and signer\nconst provider = new ethers.JsonRpcProvider("https://rpc.url");\nconst signer = new ethers.Wallet("PRIVATE_KEY", provider);\n\n// Create integration instance\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  "0xSwapProxyAddress",\n  "0xReflexRouterAddress"\n);\n\n// Encode swap for target DEX (e.g., Uniswap V2)\nconst targetDexInterface = new ethers.Interface([\n  "function swapExactTokensForTokens(uint,uint,address[],address,uint)"\n]);\n\nconst swapCalldata = targetDexInterface.encodeFunctionData(\n  "swapExactTokensForTokens",\n  [\n    ethers.parseEther("1.0"),      // amountIn\n    ethers.parseEther("0.95"),     // amountOutMin\n    [tokenInAddress, tokenOutAddress], // path\n    userAddress,                    // to\n    Math.floor(Date.now() / 1000) + 60 * 20 // deadline\n  ]\n);\n\n// Prepare swap metadata\nconst swapMetadata = {\n  swapTxCallData: swapCalldata,\n  tokenIn: tokenInAddress,\n  amountIn: ethers.parseEther("1.0"),\n  tokenOut: tokenOutAddress,\n  recipient: userAddress\n};\n\n// Prepare backrun parameters\nconst backrunParams = [\n  {\n    triggerPoolId: poolAddress,\n    swapAmountIn: ethers.parseEther("1.0"),\n    token0In: tokenInAddress < tokenOutAddress,\n    recipient: userAddress,\n    configId: ethers.ZeroHash\n  }\n];\n\n// Check and handle token approval\nconst isApproved = await integration.isTokenApproved(\n  tokenInAddress,\n  ethers.parseEther("1.0")\n);\n\nif (!isApproved) {\n  await integration.approveTokens([\n    {\n      tokenAddress: tokenInAddress,\n      amount: ethers.MaxUint256\n    }\n  ]);\n}\n\n// Execute swap with MEV capture\nconst result = await integration.swapWithBackrun(\n  swapCalldata,\n  swapMetadata,\n  backrunParams,\n  { gasLimit: 1500000n }\n);\n\nconsole.log("Transaction:", result.transactionHash);\nconsole.log("Gas used:", result.gasUsed.toString());\n\n// Check if MEV was captured\nif (result.profits.length > 0 && result.profits[0] > 0n) {\n  console.log("MEV Captured:", ethers.formatEther(result.profits[0]));\n  console.log("Profit Token:", result.profitTokens[0]);\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"usage-guides",children:"Usage Guides"}),"\n",(0,s.jsx)(n.p,{children:"For detailed integration guides and patterns, see:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../../integration/universal-dex",children:"Universal DEX Integration Guide"})," - Complete guide with React hooks and DApp examples"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../backrun-enabled-swap-proxy",children:"BackrunEnabledSwapProxy Contract"})," - Contract API reference"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);