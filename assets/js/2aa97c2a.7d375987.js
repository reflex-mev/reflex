"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[4275],{2826:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=r(4848),i=r(8453);const s={sidebar_position:1},o="ReflexRouter",c={id:"api/reflex-router",title:"ReflexRouter",description:"The core contract that orchestrates MEV capture and execution.",source:"@site/docs/api/reflex-router.md",sourceDirName:"api",slug:"/api/reflex-router",permalink:"/reflex/api/reflex-router",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/api/reflex-router.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Direct Contract Access",permalink:"/reflex/integration/direct-access"},next:{title:"ReflexAfterSwap",permalink:"/reflex/api/reflex-after-swap"}},d={},l=[{value:"Constructor",id:"constructor",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"triggerBackrun",id:"triggerbackrun",level:3},{value:"Events",id:"events",level:2},{value:"BackrunExecuted",id:"backrunexecuted",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"reflexrouter",children:"ReflexRouter"})}),"\n",(0,t.jsx)(n.p,{children:"The core contract that orchestrates MEV capture and execution."}),"\n",(0,t.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"constructor()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Sets the deployer (",(0,t.jsx)(n.code,{children:"msg.sender"}),") as the contract owner."]}),"\n",(0,t.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,t.jsx)(n.h3,{id:"triggerbackrun",children:"triggerBackrun"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"function triggerBackrun(\n    bytes32 triggerPoolId,\n    uint112 swapAmountIn,\n    bool token0In,\n    address recipient,\n    bytes32 configId\n) external override gracefulNonReentrant\n  returns (uint256 profit, address profitToken)\n"})}),"\n",(0,t.jsx)(n.p,{children:"Executes a backrun arbitrage opportunity."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"triggerPoolId"})," - Unique identifier of the triggering pool (cast from pool address)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"swapAmountIn"})," - Amount of tokens for arbitrage swap (uint112 for gas optimization)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"token0In"})," - Whether to use token0 (true) or token1 (false) as input token"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"recipient"})," - Address to receive arbitrage profit (used as dust recipient)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"configId"})," - Configuration ID for profit splitting (uses default if ",(0,t.jsx)(n.code,{children:"bytes32(0)"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"profit"})," - Amount of profit generated from the arbitrage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"profitToken"})," - Address of the token in which profit was generated"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Events Emitted:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"BackrunExecuted(triggerPoolId, swapAmountIn, token0In, profit, profitToken, recipient)"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"uint256 profit, address profitToken = reflexRouter.triggerBackrun(\n    bytes32(uint256(uint160(poolAddress))),\n    1000000, // 1 USDC (6 decimals)\n    true,    // Use token0 as input\n    msg.sender,\n    bytes32(0) // Use default config\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,t.jsx)(n.h3,{id:"backrunexecuted",children:"BackrunExecuted"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"event BackrunExecuted(\n    bytes32 indexed triggerPoolId,\n    uint112 swapAmountIn,\n    bool token0In,\n    uint256 profit,\n    address profitToken,\n    address recipient\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Emitted when a backrun is successfully executed."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Event Parameters:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"triggerPoolId"})," - Pool identifier where the backrun was triggered"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"swapAmountIn"})," - Amount of tokens used in the arbitrage"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"token0In"})," - Swap direction flag"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"profit"})," - Amount of profit captured"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"profitToken"})," - Token address in which profit was received"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"recipient"})," - Address that received the profit"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}}}]);