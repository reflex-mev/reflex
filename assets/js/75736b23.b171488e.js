"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[1188],{3354:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var t=r(4848),i=r(8453);const s={sidebar_position:4},o="Direct Contract Access",a={id:"integration/direct-access",title:"Direct Contract Access",description:"Integrate Reflex MEV capture by calling the Router directly from your custom smart contracts.",source:"@site/docs/integration/direct-access.md",sourceDirName:"integration",slug:"/integration/direct-access",permalink:"/reflex/integration/direct-access",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/integration/direct-access.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Universal DEX Integration",permalink:"/reflex/integration/universal-dex"},next:{title:"ReflexRouter",permalink:"/reflex/api/reflex-router"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Implementation",id:"implementation",level:2},{value:"Basic Integration",id:"basic-integration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Error Handling",id:"1-error-handling",level:3},{value:"2. Gas Optimization",id:"2-gas-optimization",level:3},{value:"3. Security",id:"3-security",level:3},{value:"4. Monitoring",id:"4-monitoring",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Transaction Reverts",id:"transaction-reverts",level:3},{value:"MEV Not Captured",id:"mev-not-captured",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"direct-contract-access",children:"Direct Contract Access"})}),"\n",(0,t.jsx)(n.p,{children:"Integrate Reflex MEV capture by calling the Router directly from your custom smart contracts."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["Direct Contract Access provides maximum flexibility for custom integrations. Your smart contract calls ",(0,t.jsx)(n.code,{children:"triggerBackrun()"})," directly on the ReflexRouter to capture MEV opportunities on-demand."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Best for:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"\u2705 Custom DeFi protocols with unique architectures"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Applications requiring fine-grained MEV control"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Conditional MEV capture based on custom logic"}),"\n",(0,t.jsx)(n.li,{children:"\u2705 Advanced integration scenarios"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant Contract as Your Contract\n    participant Router as Reflex Router\n\n    User->>Contract: Execute transaction\n    Contract->>Contract: Custom business logic\n    Contract->>Router: triggerBackrun()\n    Router->>Router: Capture MEV & distribute\n    Router--\x3e>User: MEV profits\n    Contract--\x3e>User: Transaction result"}),"\n",(0,t.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Full Control"}),": Decide exactly when and how to trigger MEV capture"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Custom Logic"}),": Integrate MEV capture with any business logic"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexible Configuration"}),": Choose backrun parameters per transaction"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Direct Integration"}),": No intermediary contracts required"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.h3,{id:"basic-integration",children:"Basic Integration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/interfaces/IReflexRouter.sol";\n\ncontract MyDeFiProtocol {\n    IReflexRouter public immutable reflexRouter;\n    bytes32 public immutable configId;\n\n    constructor(address _reflexRouter, bytes32 _configId) {\n        reflexRouter = IReflexRouter(_reflexRouter);\n        configId = _configId;\n    }\n\n    function executeSwapWithMEV(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external returns (uint256 amountOut) {\n        // Your custom swap logic\n        amountOut = _executeSwap(tokenIn, tokenOut, amountIn, minAmountOut);\n\n        // Trigger MEV capture after swap\n        bytes32 poolId = _getPoolId(tokenIn, tokenOut);\n        uint112 backrunAmount = uint112(amountIn);\n\n        try reflexRouter.triggerBackrun(\n            poolId,\n            backrunAmount,\n            true, // zeroForOne\n            msg.sender,\n            configId\n        ) returns (uint256 profit, address profitToken) {\n            emit MEVCaptured(msg.sender, profit, profitToken);\n        } catch {\n            // Silently fail - don\'t revert user transaction\n            emit MEVCaptureFailed(msg.sender);\n        }\n\n        return amountOut;\n    }\n\n    function _executeSwap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) internal returns (uint256) {\n        // Your swap implementation\n    }\n\n    function _getPoolId(address token0, address token1) internal pure returns (bytes32) {\n        // Your pool ID logic\n    }\n\n    event MEVCaptured(address indexed user, uint256 profit, address profitToken);\n    event MEVCaptureFailed(address indexed user);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-error-handling",children:"1. Error Handling"}),"\n",(0,t.jsx)(n.p,{children:"Always use try/catch to prevent MEV failures from affecting user transactions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"try reflexRouter.triggerBackrun(...) {\n    // Success\n} catch {\n    // Log failure but don't revert\n    emit MEVCaptureFailed(msg.sender);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-gas-optimization",children:"2. Gas Optimization"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Cache frequently used values"}),"\n",(0,t.jsx)(n.li,{children:"Use efficient pool ID calculations"}),"\n",(0,t.jsx)(n.li,{children:"Consider batching MEV triggers when possible"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"// \u274c Bad: Recalculate poolId every time\nfunction badExample(address token0, address token1) external {\n    bytes32 poolId = keccak256(abi.encodePacked(token0, token1));\n    reflexRouter.triggerBackrun(poolId, ...);\n}\n\n// \u2705 Good: Cache poolId\nmapping(bytes32 => bytes32) public poolIds;\n\nfunction goodExample(address token0, address token1) external {\n    bytes32 key = keccak256(abi.encodePacked(token0, token1));\n    bytes32 poolId = poolIds[key];\n\n    if (poolId == bytes32(0)) {\n        poolId = _calculatePoolId(token0, token1);\n        poolIds[key] = poolId;\n    }\n\n    reflexRouter.triggerBackrun(poolId, ...);\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-security",children:"3. Security"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Validate all user inputs"}),"\n",(0,t.jsx)(n.li,{children:"Use reentrancy guards where appropriate"}),"\n",(0,t.jsx)(n.li,{children:"Implement access controls for sensitive functions"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:'import "@openzeppelin/contracts/security/ReentrancyGuard.sol";\n\ncontract SecureProtocol is ReentrancyGuard {\n    function executeSwapWithMEV(...) external nonReentrant {\n        // Protected from reentrancy\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"4-monitoring",children:"4. Monitoring"}),"\n",(0,t.jsx)(n.p,{children:"Emit events for off-chain monitoring:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"event MEVCaptured(\n    address indexed user,\n    uint256 profit,\n    address profitToken,\n    bytes32 poolId,\n    uint256 backrunAmount\n);\n\nevent MEVCaptureFailed(\n    address indexed user,\n    bytes32 poolId,\n    string reason\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(n.h3,{id:"transaction-reverts",children:"Transaction Reverts"}),"\n",(0,t.jsx)(n.p,{children:"If transactions revert unexpectedly:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Ensure proper try/catch around ",(0,t.jsx)(n.code,{children:"triggerBackrun()"})]}),"\n",(0,t.jsx)(n.li,{children:"Check gas limits are sufficient"}),"\n",(0,t.jsx)(n.li,{children:"Verify pool ID is correct"}),"\n",(0,t.jsx)(n.li,{children:"Confirm Router address is correct"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mev-not-captured",children:"MEV Not Captured"}),"\n",(0,t.jsx)(n.p,{children:"If MEV capture fails silently:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Check event logs for ",(0,t.jsx)(n.code,{children:"MEVCaptureFailed"})," events"]}),"\n",(0,t.jsx)(n.li,{children:"Verify pool has sufficient liquidity"}),"\n",(0,t.jsx)(n.li,{children:"Ensure backrun amount is within reasonable bounds"}),"\n",(0,t.jsx)(n.li,{children:"Test profitability threshold requirements"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Next Steps:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../api/reflex-router",children:"View API Reference"})," - Complete Router documentation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"../architecture",children:"Read Architecture Guide"})," - Understand system design"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"./overview",children:"Explore Other Integration Methods"})," - Compare integration options"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);