"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[628],{3777:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var i=r(4848),s=r(8453);const t={sidebar_position:1},d="Smart Contracts API",l={id:"technical/api/smart-contracts",title:"Smart Contracts API",description:"Complete API reference for Reflex Protocol smart contracts, covering all functions, events, and data structures.",source:"@site/docs/technical/api/smart-contracts.md",sourceDirName:"technical/api",slug:"/technical/api/smart-contracts",permalink:"/reflex/technical/api/smart-contracts",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/technical/api/smart-contracts.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Basic Backrun Example",permalink:"/reflex/technical/examples/basic-backrun"},next:{title:"SDK Reference",permalink:"/reflex/technical/api/sdk-reference"}},o={},c=[{value:"\ud83d\udccb Contract Overview",id:"-contract-overview",level:2},{value:"\ud83c\udfaf ReflexRouter",id:"-reflexrouter",level:2},{value:"Constructor",id:"constructor",level:3},{value:"State Variables",id:"state-variables",level:3},{value:"Core Functions",id:"core-functions",level:3},{value:"triggerBackrun",id:"triggerbackrun",level:4},{value:"backrunedExecute",id:"backrunedexecute",level:4},{value:"Administrative Functions",id:"administrative-functions",level:3},{value:"setReflexQuoter",id:"setreflexquoter",level:4},{value:"getReflexAdmin",id:"getreflexadmin",level:4},{value:"withdrawToken",id:"withdrawtoken",level:4},{value:"withdrawEth",id:"withdraweth",level:4},{value:"Internal Functions",id:"internal-functions",level:3},{value:"decodeIsZeroForOne",id:"decodeiszeroforone",level:4},{value:"Events",id:"events",level:3},{value:"BackrunExecuted",id:"backrunexecuted",level:4},{value:"\ud83d\udca1 ReflexQuoter",id:"-reflexquoter",level:2},{value:"Core Functions",id:"core-functions-1",level:3},{value:"getQuote",id:"getquote",level:4},{value:"Data Structures",id:"data-structures",level:3},{value:"SwapDecodedData",id:"swapdecodeddata",level:4},{value:"\ud83d\udcb0 ConfigurableRevenueDistributor",id:"-configurablerevenuedistributor",level:2},{value:"Core Functions",id:"core-functions-2",level:3},{value:"configureRevenue",id:"configurerevenue",level:4},{value:"distributeRevenue",id:"distributerevenue",level:4},{value:"getRevenueConfig",id:"getrevenueconfig",level:4},{value:"Events",id:"events-1",level:3},{value:"RevenueConfigured",id:"revenueconfigured",level:4},{value:"RevenueDistributed",id:"revenuedistributed",level:4},{value:"\ud83d\udd0c ReflexAfterSwap (Base Plugin)",id:"-reflexafterswap-base-plugin",level:2},{value:"Constructor",id:"constructor-1",level:3},{value:"Abstract Functions",id:"abstract-functions",level:3},{value:"afterSwap",id:"afterswap",level:4},{value:"Modifiers",id:"modifiers",level:3},{value:"onlyPool",id:"onlypool",level:4},{value:"\ud83d\udcca Gas Usage Reference",id:"-gas-usage-reference",level:2},{value:"\ud83d\udd0d Error Codes",id:"-error-codes",level:2},{value:"ReflexRouter Errors",id:"reflexrouter-errors",level:3},{value:"RevenueDistributor Errors",id:"revenuedistributor-errors",level:3},{value:"\ud83d\udd17 Contract Addresses",id:"-contract-addresses",level:2},{value:"Mainnet",id:"mainnet",level:3},{value:"Goerli Testnet",id:"goerli-testnet",level:3},{value:"Polygon",id:"polygon",level:3},{value:"\ud83d\udcd6 Integration Examples",id:"-integration-examples",level:2},{value:"Basic Integration",id:"basic-integration",level:3},{value:"Advanced Revenue Configuration",id:"advanced-revenue-configuration",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"smart-contracts-api",children:"Smart Contracts API"})}),"\n",(0,i.jsx)(n.p,{children:"Complete API reference for Reflex Protocol smart contracts, covering all functions, events, and data structures."}),"\n",(0,i.jsx)(n.h2,{id:"-contract-overview",children:"\ud83d\udccb Contract Overview"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Contract"}),(0,i.jsx)(n.th,{children:"Address"}),(0,i.jsx)(n.th,{children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ReflexRouter"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0x742d..."})}),(0,i.jsx)(n.td,{children:"Main router for MEV capture and execution"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ReflexQuoter"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0x9E54..."})}),(0,i.jsx)(n.td,{children:"Price quoter and route optimizer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"ConfigurableRevenueDistributor"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0x1A2B..."})}),(0,i.jsx)(n.td,{children:"Revenue sharing management"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"-reflexrouter",children:"\ud83c\udfaf ReflexRouter"}),"\n",(0,i.jsx)(n.p,{children:"The core contract that orchestrates MEV capture and execution."}),"\n",(0,i.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"constructor()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Sets the deployer (",(0,i.jsx)(n.code,{children:"tx.origin"}),") as the contract owner."]}),"\n",(0,i.jsx)(n.h3,{id:"state-variables",children:"State Variables"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"address public owner;\naddress public reflexQuoter;\nuint8 private loanCallbackType;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"core-functions",children:"Core Functions"}),"\n",(0,i.jsx)(n.h4,{id:"triggerbackrun",children:"triggerBackrun"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function triggerBackrun(\n    bytes32 triggerPoolId,\n    uint112 swapAmountIn,\n    bool token0In,\n    address recipient,\n    bytes32 configId\n) external override gracefulNonReentrant\n  returns (uint256 profit, address profitToken)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Executes a backrun arbitrage opportunity."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"triggerPoolId"})," - Unique identifier of the triggering pool (cast from pool address)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"swapAmountIn"})," - Amount of tokens for arbitrage swap (uint112 for gas optimization)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"token0In"})," - Whether to use token0 (true) or token1 (false) as input token"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recipient"})," - Address to receive arbitrage profit (used as dust recipient)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"configId"})," - Configuration ID for profit splitting (uses default if ",(0,i.jsx)(n.code,{children:"bytes32(0)"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profit"})," - Amount of profit generated from the arbitrage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profitToken"})," - Address of the token in which profit was generated"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Events Emitted:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"BackrunExecuted(triggerPoolId, swapAmountIn, token0In, profit, profitToken, recipient)"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Gas Usage:"})," ~150,000 gas (varies by route complexity)"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"uint256 profit, address profitToken = reflexRouter.triggerBackrun(\n    bytes32(uint256(uint160(poolAddress))),\n    1000000, // 1 USDC (6 decimals)\n    true,    // Use token0 as input\n    msg.sender,\n    bytes32(0) // Use default config\n);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"backrunedexecute",children:"backrunedExecute"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function backrunedExecute(\n    ExecuteParams calldata executeParams,\n    BackrunParams[] calldata backrunParams\n) external payable override gracefulNonReentrant\n  returns (\n    bool success,\n    bytes memory returnData,\n    uint256[] memory profits,\n    address[] memory profitTokens\n  )\n"})}),"\n",(0,i.jsx)(n.p,{children:"Executes arbitrary calldata and then triggers multiple backruns with failsafe mechanisms."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct ExecuteParams {\n    address target;   // Target contract to call\n    uint256 value;    // ETH value to send\n    bytes callData;   // Encoded function call\n}\n\nstruct BackrunParams {\n    bytes32 triggerPoolId;\n    uint112 swapAmountIn;\n    bool token0In;\n    address recipient;\n    bytes32 configId;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"success"})," - Whether the initial call succeeded"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"returnData"})," - Return data from the initial call"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profits"})," - Array of profits from each backrun (0 if failed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profitTokens"})," - Array of profit tokens (address(0) if failed)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u2705 Atomic execution with rollback protection"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Individual backrun failure isolation"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 Batch profit optimization"}),"\n",(0,i.jsx)(n.li,{children:"\u2705 ETH value forwarding support"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"administrative-functions",children:"Administrative Functions"}),"\n",(0,i.jsx)(n.h4,{id:"setreflexquoter",children:"setReflexQuoter"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function setReflexQuoter(address _reflexQuoter) public isAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Sets the ReflexQuoter contract address."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Admin only"]}),"\n",(0,i.jsx)(n.h4,{id:"getreflexadmin",children:"getReflexAdmin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getReflexAdmin() public view returns (address)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Returns the contract admin address."}),"\n",(0,i.jsx)(n.h4,{id:"withdrawtoken",children:"withdrawToken"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function withdrawToken(address token, uint256 amount, address _to) public isAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Withdraws ERC20 tokens from the contract."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Admin only"]}),"\n",(0,i.jsx)(n.h4,{id:"withdraweth",children:"withdrawEth"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function withdrawEth(uint256 amount, address payable _to) public isAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Withdraws ETH from the contract."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Access:"})," Admin only"]}),"\n",(0,i.jsx)(n.h3,{id:"internal-functions",children:"Internal Functions"}),"\n",(0,i.jsx)(n.h4,{id:"decodeiszeroforone",children:"decodeIsZeroForOne"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function decodeIsZeroForOne(uint256 b) public pure returns (bool zeroForOne)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Decodes swap direction from metadata byte using bitwise operations."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// 1 byte - <1 bit zeroForOne><7 bits other data>\nfunction decodeIsZeroForOne(uint256 b) public pure returns (bool zeroForOne) {\n    assembly {\n        zeroForOne := and(b, 0x80)\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"events",children:"Events"}),"\n",(0,i.jsx)(n.h4,{id:"backrunexecuted",children:"BackrunExecuted"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event BackrunExecuted(\n    bytes32 indexed triggerPoolId,\n    uint112 swapAmountIn,\n    bool token0In,\n    uint256 profit,\n    address profitToken,\n    address recipient\n);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Emitted when a backrun is successfully executed."}),"\n",(0,i.jsx)(n.h2,{id:"-reflexquoter",children:"\ud83d\udca1 ReflexQuoter"}),"\n",(0,i.jsx)(n.p,{children:"Interface for the price quoter and route optimizer."}),"\n",(0,i.jsx)(n.h3,{id:"core-functions-1",children:"Core Functions"}),"\n",(0,i.jsx)(n.h4,{id:"getquote",children:"getQuote"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getQuote(\n    address triggerPool,\n    uint8 tokenInIndex,\n    uint256 amountIn\n) external view returns (\n    uint256 profit,\n    SwapDecodedData memory decoded,\n    uint256[] memory amountsOut,\n    uint256 initialHopIndex\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Analyzes arbitrage opportunities and returns optimal execution parameters."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"triggerPool"})," - Address of the pool that triggered the opportunity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"tokenInIndex"})," - Index of input token (0 for token0, 1 for token1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amountIn"})," - Amount of input tokens for the arbitrage"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"profit"})," - Estimated profit from the arbitrage (0 if not profitable)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"decoded"})," - Swap route data structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amountsOut"})," - Token amounts for each hop in the route"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"initialHopIndex"})," - Starting index for the swap route"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"data-structures",children:"Data Structures"}),"\n",(0,i.jsx)(n.h4,{id:"swapdecodeddata",children:"SwapDecodedData"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"struct SwapDecodedData {\n    address[] pools;     // Array of pool addresses in the route\n    uint8[] dexType;     // DEX type for each pool (UniV2, UniV3, etc.)\n    uint8[] dexMeta;     // Metadata for each pool (swap direction, etc.)\n    address[] tokens;    // Token addresses involved in the route\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"DEX Types:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"1"})," - UniswapV2 (with callback)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"2"})," - UniswapV2 (without callback)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"3"})," - UniswapV3"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"4"})," - Curve"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"5"})," - Balancer"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"6"})," - Algebra (Quickswap)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-configurablerevenuedistributor",children:"\ud83d\udcb0 ConfigurableRevenueDistributor"}),"\n",(0,i.jsx)(n.p,{children:"Manages profit distribution across multiple stakeholders."}),"\n",(0,i.jsx)(n.h3,{id:"core-functions-2",children:"Core Functions"}),"\n",(0,i.jsx)(n.h4,{id:"configurerevenue",children:"configureRevenue"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function configureRevenue(\n    bytes32 configId,\n    address[] calldata recipients,\n    uint256[] calldata shares\n) external onlyFundsAdmin\n"})}),"\n",(0,i.jsx)(n.p,{children:"Configures profit distribution for a specific configuration ID."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"configId"})," - Unique identifier for the configuration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"recipients"})," - Array of recipient addresses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"shares"})," - Array of share percentages (must sum to 100)"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Constraints:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maximum 10 recipients per configuration"}),"\n",(0,i.jsx)(n.li,{children:"Shares must sum to exactly 100"}),"\n",(0,i.jsx)(n.li,{children:"Recipients must be non-zero addresses"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"distributerevenue",children:"distributeRevenue"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function distributeRevenue(\n    bytes32 configId,\n    address token,\n    uint256 amount,\n    address dustRecipient\n) external returns (uint256[] memory distributed)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Distributes revenue according to the specified configuration."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"configId"})," - Configuration to use for distribution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"token"})," - ERC20 token to distribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"amount"})," - Total amount to distribute"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dustRecipient"})," - Address to receive any remaining dust"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"distributed"})," - Array of amounts distributed to each recipient"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"getrevenueconfig",children:"getRevenueConfig"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function getRevenueConfig(bytes32 configId)\n    external view returns (\n        address[] memory recipients,\n        uint256[] memory shares,\n        bool isActive\n    )\n"})}),"\n",(0,i.jsx)(n.p,{children:"Retrieves the revenue configuration for a given ID."}),"\n",(0,i.jsx)(n.h3,{id:"events-1",children:"Events"}),"\n",(0,i.jsx)(n.h4,{id:"revenueconfigured",children:"RevenueConfigured"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event RevenueConfigured(\n    bytes32 indexed configId,\n    address[] recipients,\n    uint256[] shares\n);\n"})}),"\n",(0,i.jsx)(n.h4,{id:"revenuedistributed",children:"RevenueDistributed"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"event RevenueDistributed(\n    bytes32 indexed configId,\n    address indexed token,\n    uint256 totalAmount,\n    uint256[] amounts\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-reflexafterswap-base-plugin",children:"\ud83d\udd0c ReflexAfterSwap (Base Plugin)"}),"\n",(0,i.jsx)(n.p,{children:"Abstract base contract for DEX plugin integration."}),"\n",(0,i.jsx)(n.h3,{id:"constructor-1",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"constructor(address _reflexRouter, address _pool)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_reflexRouter"})," - Address of the ReflexRouter contract"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"_pool"})," - Address of the target pool to monitor"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"abstract-functions",children:"Abstract Functions"}),"\n",(0,i.jsx)(n.h4,{id:"afterswap",children:"afterSwap"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function afterSwap(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n) external virtual\n"})}),"\n",(0,i.jsx)(n.p,{children:"Called after each swap to trigger MEV capture. Must be implemented by derived contracts."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation Example:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function afterSwap(\n    address sender,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n) external override onlyPool {\n    uint256 swapAmount = amount0 > 0 ? amount0 : amount1;\n    bool token0In = amount0 > 0;\n\n    if (swapAmount >= minBackrunThreshold) {\n        reflexRouter.triggerBackrun(\n            bytes32(uint256(uint160(pool))),\n            uint112(swapAmount / 10), // 10% of swap size\n            token0In,\n            sender, // Give profits to swapper\n            defaultConfigId\n        );\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"modifiers",children:"Modifiers"}),"\n",(0,i.jsx)(n.h4,{id:"onlypool",children:"onlyPool"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'modifier onlyPool() {\n    require(msg.sender == pool, "Only pool can call");\n    _;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"-gas-usage-reference",children:"\ud83d\udcca Gas Usage Reference"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Function"}),(0,i.jsx)(n.th,{children:"Typical Gas"}),(0,i.jsx)(n.th,{children:"Max Gas"}),(0,i.jsx)(n.th,{children:"Notes"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"triggerBackrun"})}),(0,i.jsx)(n.td,{children:"150,000"}),(0,i.jsx)(n.td,{children:"300,000"}),(0,i.jsx)(n.td,{children:"Varies by route length"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"backrunedExecute"})}),(0,i.jsx)(n.td,{children:"200,000"}),(0,i.jsx)(n.td,{children:"500,000"}),(0,i.jsx)(n.td,{children:"Base + execution costs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"configureRevenue"})}),(0,i.jsx)(n.td,{children:"80,000"}),(0,i.jsx)(n.td,{children:"120,000"}),(0,i.jsx)(n.td,{children:"One-time setup"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"distributeRevenue"})}),(0,i.jsx)(n.td,{children:"50,000 + (recipients \xd7 20,000)"}),(0,i.jsx)(n.td,{children:"250,000"}),(0,i.jsx)(n.td,{children:"Scales with recipients"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"getQuote"})}),(0,i.jsx)(n.td,{children:"30,000"}),(0,i.jsx)(n.td,{children:"100,000"}),(0,i.jsx)(n.td,{children:"View function (off-chain)"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"-error-codes",children:"\ud83d\udd0d Error Codes"}),"\n",(0,i.jsx)(n.h3,{id:"reflexrouter-errors",children:"ReflexRouter Errors"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"error InsufficientProfit(uint256 required, uint256 available);\nerror InvalidPoolId(bytes32 poolId);\nerror UnauthorizedCallback(address caller);\nerror InvalidSwapAmount(uint256 amount);\nerror CallbackTypeMismatch(uint8 expected, uint8 actual);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"revenuedistributor-errors",children:"RevenueDistributor Errors"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"error InvalidConfiguration(bytes32 configId);\nerror SharesSumError(uint256 sum);\nerror TooManyRecipients(uint256 count);\nerror ZeroAddress();\nerror InsufficientBalance(uint256 required, uint256 available);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-contract-addresses",children:"\ud83d\udd17 Contract Addresses"}),"\n",(0,i.jsx)(n.h3,{id:"mainnet",children:"Mainnet"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ReflexRouter:     0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3\nReflexQuoter:     0x9E545E3C0baAB3E08CdfD552C960A1050f373042\n"})}),"\n",(0,i.jsx)(n.h3,{id:"goerli-testnet",children:"Goerli Testnet"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ReflexRouter:     0x1234567890123456789012345678901234567890\nReflexQuoter:     0x0987654321098765432109876543210987654321\n"})}),"\n",(0,i.jsx)(n.h3,{id:"polygon",children:"Polygon"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ReflexRouter:     0xABCDEF1234567890ABCDEF1234567890ABCDEF12\nReflexQuoter:     0x1234567890ABCDEF1234567890ABCDEF12345678\n"})}),"\n",(0,i.jsx)(n.h2,{id:"-integration-examples",children:"\ud83d\udcd6 Integration Examples"}),"\n",(0,i.jsx)(n.h3,{id:"basic-integration",children:"Basic Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract MyDEXPlugin is ReflexAfterSwap {\n    uint256 public constant MIN_BACKRUN_AMOUNT = 1e18;\n    bytes32 public constant CONFIG_ID = keccak256("MY_DEX_CONFIG");\n\n    constructor(address _reflexRouter, address _pool)\n        ReflexAfterSwap(_reflexRouter, _pool) {}\n\n    function afterSwap(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override onlyPool {\n        uint256 swapAmount = amount0 > 0 ? amount0 : amount1;\n\n        if (swapAmount >= MIN_BACKRUN_AMOUNT) {\n            try reflexRouter.triggerBackrun(\n                bytes32(uint256(uint160(pool))),\n                uint112(swapAmount / 20), // 5% of swap\n                amount0 > 0,\n                sender,\n                CONFIG_ID\n            ) returns (uint256 profit, address profitToken) {\n                emit BackrunSuccess(sender, profit, profitToken);\n            } catch Error(string memory reason) {\n                emit BackrunFailed(sender, reason);\n            }\n        }\n    }\n\n    event BackrunSuccess(address indexed user, uint256 profit, address token);\n    event BackrunFailed(address indexed user, string reason);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"advanced-revenue-configuration",children:"Advanced Revenue Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'// Configure 4-way profit split\naddress[] memory recipients = new address[](4);\nrecipients[0] = protocolTreasury;    // 40%\nrecipients[1] = userAddress;         // 30%\nrecipients[2] = lpProviders;         // 20%\nrecipients[3] = validatorTips;       // 10%\n\nuint256[] memory shares = new uint256[](4);\nshares[0] = 40;\nshares[1] = 30;\nshares[2] = 20;\nshares[3] = 10;\n\nreflexRouter.configureRevenue(\n    keccak256("ADVANCED_CONFIG"),\n    recipients,\n    shares\n);\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["For more implementation details and examples, see our ",(0,i.jsx)(n.a,{href:"../integration/overview",children:"Integration Guide"})," and ",(0,i.jsx)(n.a,{href:"../examples/basic-backrun",children:"Examples"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}}}]);