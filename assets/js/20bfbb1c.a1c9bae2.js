"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[517],{47:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var r=t(4848),s=t(8453);const a={sidebar_position:3},i="SDK Integration",o={id:"integration/sdk-integration",title:"SDK Integration",description:"Integrate Reflex MEV capture into your client applications, DApps, and custom trading strategies using the TypeScript SDK.",source:"@site/docs/integration/sdk-integration.md",sourceDirName:"integration",slug:"/integration/sdk-integration",permalink:"/reflex/integration/sdk-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/integration/sdk-integration.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Smart Contract Integration",permalink:"/reflex/integration/smart-contract"},next:{title:"Smart Contracts API",permalink:"/reflex/api/smart-contracts"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Installation",id:"installation",level:2},{value:"Quick Start",id:"quick-start",level:2},{value:"Basic Setup",id:"basic-setup",level:3},{value:"DApp Integration",id:"dapp-integration",level:2},{value:"Frontend Integration",id:"frontend-integration",level:3},{value:"Trading Interface Component",id:"trading-interface-component",level:3},{value:"Configuration and Optimization",id:"configuration-and-optimization",level:2},{value:"Gas Management",id:"gas-management",level:3},{value:"Event Monitoring",id:"event-monitoring",level:3},{value:"Testing",id:"testing",level:2},{value:"Mock Environment",id:"mock-environment",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Performance",id:"performance",level:3},{value:"Security",id:"security",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sdk-integration",children:"SDK Integration"})}),"\n",(0,r.jsx)(n.p,{children:"Integrate Reflex MEV capture into your client applications, DApps, and custom trading strategies using the TypeScript SDK."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Reflex SDK provides a powerful and easy-to-use interface for building MEV-enabled DApps. Whether you're integrating MEV capture into a DApp frontend or creating custom trading interfaces, the SDK handles the complexity of interacting with Reflex smart contracts."}),"\n",(0,r.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @reflex-mev/sdk ethers\n# or\nyarn add @reflex-mev/sdk ethers\n"})}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { ReflexSDK } from "@reflex-mev/sdk";\nimport { ethers } from "ethers";\n\n// Initialize provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  "https://mainnet.infura.io/v3/YOUR_KEY"\n);\nconst signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);\n\n// Create SDK instance\nconst reflex = new ReflexSDK(provider, signer, {\n  routerAddress: "0xYourReflexRouterAddress",\n  defaultGasLimit: 300000n,\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"dapp-integration",children:"DApp Integration"}),"\n",(0,r.jsx)(n.h3,{id:"frontend-integration",children:"Frontend Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// React hook for MEV integration\nimport { useState, useEffect, useCallback } from "react";\nimport { ReflexSDK } from "@reflex-mev/sdk";\n\nexport function useReflexMEV(provider, signer) {\n  const [reflex, setReflex] = useState(null);\n  const [mevStats, setMevStats] = useState({\n    totalCaptured: 0n,\n    userRewards: 0n,\n    successRate: 0,\n  });\n\n  useEffect(() => {\n    if (provider && signer) {\n      const reflexInstance = new ReflexSDK(provider, signer, {\n        routerAddress: "0xYourReflexRouterAddress",\n        defaultGasLimit: 500000n,\n      });\n\n      setReflex(reflexInstance);\n\n      // Note: Event listening would be implemented through provider event filters\n      // Example: Listen for BackrunExecuted events directly from the contract\n    }\n  }, [provider, signer]);\n\n  const executeSwapWithMEV = useCallback(\n    async (swapParams) => {\n      if (!reflex) return null;\n\n      try {\n        // Prepare the user\'s swap transaction as executeParams\n        const executeParams = {\n          target: swapParams.poolAddress,\n          value: swapParams.value || 0n,\n          callData: swapParams.swapCallData,\n        };\n\n        // Prepare backrun parameters (array of BackrunParams)\n        const backrunParams = [\n          {\n            triggerPoolId: swapParams.poolAddress,\n            swapAmountIn: swapParams.amountIn / 20n, // 5% of swap\n            token0In: swapParams.token0In,\n            recipient: swapParams.user,\n            configId: swapParams.configId,\n          },\n        ];\n\n        // Execute swap + MEV capture atomically\n        const result = await reflex.backrunedExecute(\n          executeParams,\n          backrunParams\n        );\n\n        return {\n          success: result.success,\n          transactionHash: result.transactionHash,\n          returnData: result.returnData,\n          profits: result.profits,\n          profitTokens: result.profitTokens,\n        };\n      } catch (error) {\n        console.error("Swap with MEV failed:", error);\n        throw error;\n      }\n    },\n    [reflex]\n  );\n\n  return {\n    reflex,\n    mevStats,\n    executeSwapWithMEV,\n    isReady: !!reflex,\n  };\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"trading-interface-component",children:"Trading Interface Component"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// MEV-enabled trading component\nimport React, { useState } from "react";\n\nexport function MEVTradingInterface({ useReflexMEV }) {\n  const { executeSwapWithMEV, mevStats, isReady } = useReflexMEV(\n    provider,\n    signer\n  );\n  const [swapAmount, setSwapAmount] = useState("");\n  const [isSwapping, setIsSwapping] = useState(false);\n\n  const handleSwap = async () => {\n    setIsSwapping(true);\n\n    try {\n      const result = await executeSwapWithMEV({\n        tokenIn: selectedTokenIn.address,\n        tokenOut: selectedTokenOut.address,\n        amountIn: ethers.parseEther(swapAmount),\n        poolAddress: poolAddress,\n        user: userAddress,\n        token0In: selectedTokenIn.address < selectedTokenOut.address,\n        swapCallData: encodedSwapData, // Pre-encoded swap transaction\n      });\n\n      if (\n        result.success &&\n        result.profits.length > 0 &&\n        result.profits[0] > 0n\n      ) {\n        showNotification({\n          type: "success",\n          title: "Swap Completed with MEV Bonus!",\n          message: `You received an additional ${ethers.formatEther(\n            result.profits[0]\n          )} ${result.profitTokens[0]} from MEV capture`,\n        });\n      }\n    } catch (error) {\n      showNotification({\n        type: "error",\n        title: "Swap Failed",\n        message: error.message,\n      });\n    } finally {\n      setIsSwapping(false);\n    }\n  };\n\n  return (\n    <div className="trading-interface">\n      {/* MEV Stats Display */}\n      <div className="mev-stats">\n        <h3>MEV Benefits</h3>\n        <div>\n          Total Captured: {ethers.formatEther(mevStats.totalCaptured)} ETH\n        </div>\n        <div>Your Rewards: {ethers.formatEther(mevStats.userRewards)} ETH</div>\n        <div>Success Rate: {(mevStats.successRate * 100).toFixed(1)}%</div>\n      </div>\n\n      {/* Trading Interface */}\n      <div className="swap-form">\n        <input\n          type="number"\n          value={swapAmount}\n          onChange={(e) => setSwapAmount(e.target.value)}\n          placeholder="Amount to swap"\n        />\n\n        <button\n          onClick={handleSwap}\n          disabled={!isReady || isSwapping}\n          className="swap-button"\n        >\n          {isSwapping ? "Swapping..." : "Swap with MEV Protection"}\n        </button>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-and-optimization",children:"Configuration and Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"gas-management",children:"Gas Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Advanced gas optimization\nconst reflex = new ReflexSDK(provider, signer, {\n  routerAddress: "0xYourReflexRouterAddress",\n  defaultGasLimit: 500000n,\n  gasPriceMultiplier: 1.2,\n});\n\n// Transaction options can be passed to backrunedExecute\nconst options = {\n  gasLimit: 600000n,\n  maxFeePerGas: ethers.parseUnits("100", "gwei"),\n  maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"),\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"event-monitoring",children:"Event Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Event monitoring through provider\nimport { Interface } from "ethers";\nimport { REFLEX_ROUTER_ABI } from "@reflex-mev/sdk";\n\nconst routerInterface = new Interface(REFLEX_ROUTER_ABI);\n\n// Listen for BackrunExecuted events\nprovider.on(\n  {\n    address: reflexConfig.routerAddress,\n    topics: [routerInterface.getEvent("BackrunExecuted").topicHash],\n  },\n  (log) => {\n    const event = routerInterface.parseLog(log);\n\n    analytics.track("MEV_Captured", {\n      profit: event.args.profit,\n      triggerPoolId: event.args.triggerPoolId,\n      recipient: event.args.recipient,\n      timestamp: Date.now(),\n    });\n  }\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.h3,{id:"mock-environment",children:"Mock Environment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Test your integration\nimport { ethers } from "ethers";\nimport { ReflexSDK } from "@reflex-mev/sdk";\n\ndescribe("MEV Integration", () => {\n  let reflex: ReflexSDK;\n  let provider: ethers.Provider;\n  let signer: ethers.Wallet;\n\n  beforeEach(() => {\n    // Create test provider and wallet\n    provider = new ethers.JsonRpcProvider("http://localhost:8545");\n    signer = new ethers.Wallet("0x" + "1".repeat(64), provider);\n\n    reflex = new ReflexSDK(provider, signer, {\n      routerAddress: "0x1234567890123456789012345678901234567890",\n      defaultGasLimit: 500000n,\n    });\n  });\n\n  it("should capture MEV successfully", async () => {\n    const executeParams = {\n      target: "0x1234567890123456789012345678901234567890",\n      value: 0n,\n      callData: "0x123456", // encoded swap data\n    };\n\n    const backrunParams = [\n      {\n        triggerPoolId: "0x1234567890123456789012345678901234567890",\n        swapAmountIn: ethers.parseEther("1"),\n        token0In: true,\n        recipient: "0x1234567890123456789012345678901234567890",\n        configId:\n          "0x0000000000000000000000000000000000000000000000000000000000000000",\n      },\n    ];\n\n    const result = await reflex.backrunedExecute(executeParams, backrunParams);\n\n    expect(result.success).toBe(true);\n    expect(result.profits.length).toBeGreaterThan(0);\n    expect(result.profits[0]).toBeGreaterThan(0n);\n  });\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Always handle SDK errors gracefully"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Implement retry logic for network issues"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Use try/catch for all async operations"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Monitor and log all MEV attempts"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"performance",children:"Performance"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Cache frequently used data"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Use batch operations when possible"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Implement connection pooling"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Monitor gas usage patterns"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"security",children:"Security"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Never expose private keys in frontend code"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Validate all user inputs"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Use secure RPC endpoints"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Implement rate limiting"})}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:["For revenue configuration details, see the ",(0,r.jsx)(n.a,{href:"./revenue-configuration",children:"Revenue Configuration Guide"}),".\nFor smart contract integration, see the ",(0,r.jsx)(n.a,{href:"./smart-contract",children:"Smart Contract Integration Guide"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);