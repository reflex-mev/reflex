"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[2443],{8798:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var t=i(4848),r=i(8453);const s={sidebar_position:1},a="Architecture",c={id:"architecture",title:"Architecture",description:"Understanding Reflex's architecture is key to building effective MEV capture strategies.",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/architecture",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/architecture.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/"},next:{title:"Integration Overview",permalink:"/integration/overview"}},o={},l=[{value:"\ud83c\udfd7\ufe0f High-Level Architecture",id:"\ufe0f-high-level-architecture",level:2},{value:"Core Components Per Chain",id:"core-components-per-chain",level:3},{value:"On-chain Clients",id:"on-chain-clients",level:3},{value:"Off-chain Clients",id:"off-chain-clients",level:3},{value:"Key principle across the stack:",id:"key-principle-across-the-stack",level:3},{value:"\ud83e\udde9 Core Components",id:"-core-components",level:2},{value:"1. Reflex Router",id:"1-reflex-router",level:3},{value:"2. Reflex Quoter",id:"2-reflex-quoter",level:3},{value:"3. Reflex Backend System (Off-chain Monitoring &amp; Maintenance)",id:"3-reflex-backend-system-off-chain-monitoring--maintenance",level:3},{value:"4. Integration Types",id:"4-integration-types",level:3},{value:"\ud83d\udd04 Transaction Flow",id:"-transaction-flow",level:2},{value:"Standard Backrun Flow",id:"standard-backrun-flow",level:3},{value:"\ud83d\udca1 Capabilities",id:"-capabilities",level:2},{value:"1. Slippage Correction \u2014 Deterministic Arbitrage Execution",id:"1-slippage-correction--deterministic-arbitrage-execution",level:3},{value:"2. Sandwich Attack Prevention \u2014 Structural Immunity",id:"2-sandwich-attack-prevention--structural-immunity",level:3},{value:"\ud83d\udee1\ufe0f Security Architecture",id:"\ufe0f-security-architecture",level:2},{value:"Reflex Security",id:"reflex-security",level:3},{value:"Risk Mitigation",id:"risk-mitigation",level:3},{value:"\ud83d\udd27 Efficient Profit Detection",id:"-efficient-profit-detection",level:2},{value:"\ud83c\udf10 Multi-Chain Architecture",id:"-multi-chain-architecture",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,t.jsx)(n.p,{children:"Understanding Reflex's architecture is key to building effective MEV capture strategies."}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-high-level-architecture",children:"\ud83c\udfd7\ufe0f High-Level Architecture"}),"\n",(0,t.jsx)(n.p,{children:"Reflex operates through a simple yet powerful architecture consisting of core smart contracts deployed per chain and multiple integration pathways for different entities. The system is designed to capture MEV opportunities and distribute profits fairly across the ecosystem."}),"\n",(0,t.jsx)(n.h3,{id:"core-components-per-chain",children:"Core Components Per Chain"}),"\n",(0,t.jsx)(n.p,{children:"Each blockchain network has two core Reflex contracts:"}),"\n",(0,t.jsx)(n.mermaid,{value:'graph LR\n    subgraph "Users"\n        UserGroup[\ud83d\udc64 Users<br/>Traders & DeFi Users]\n    end\n\n    subgraph "Core Smart Contracts (Per Chain)"\n        Router[\u26a1 Reflex Router<br/>Execution engine]\n        Quoter[\ud83e\udde0 Reflex Quoter<br/>Profit detection & path optimization]\n        Router <--\x3e Quoter\n    end\n\n    subgraph "Onchain Clients"\n        PluginDEX[\ud83d\udd0c Plugin-based DEX<br/>Automatic MEV capture via hooks]\n        DirectDEX[\ud83c\udfea Custom Contracts<br/>Direct router integration]\n        SwapProxy[\ud83d\udd04 SwapProxy<br/>]\n    end\n\n    subgraph "Offchain Clients"\n        SDKApps[\ud83d\udcf1 SDK Applications<br/>]\n    end\n\n    %% User transactions trigger MEV opportunities\n    UserGroup --\x3e|Swap| PluginDEX\n    UserGroup --\x3e|Swap| DirectDEX\n    UserGroup --\x3e|Interact| SDKApps\n\n    %% Client connections to core contracts\n    PluginDEX --\x3e|triggerBackrun| Router\n    DirectDEX --\x3e|triggerBackrun| Router\n    SDKApps --\x3e|Swap| SwapProxy\n    SwapProxy --\x3e|triggerBackrun| Router'}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reflex Router"})," - The central execution engine that coordinates all MEV capture activities. Handles MEV capture through ",(0,t.jsx)(n.code,{children:"triggerBackrun()"})," for direct integrations and plugin-based systems."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reflex Quoter"})," - The analysis engine that detects MEV opportunities by analyzing price differences across DEX pools, calculating optimal arbitrage routes, and estimating profitability."]}),"\n",(0,t.jsx)(n.h3,{id:"on-chain-clients",children:"On-chain Clients"}),"\n",(0,t.jsx)(n.p,{children:"Smart contracts that integrate directly with Reflex \u2014 with all logic executed fully on-chain, no external APIs, no latency, no trust assumptions."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Plugin-based DEXes"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use hooks to automatically capture MEV immediately after user swaps"}),"\n",(0,t.jsx)(n.li,{children:"Execution is fully on-chain, deterministic, and atomic"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Custom execution contracts"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Integrate the Reflex router directly inside their core logic"}),"\n",(0,t.jsx)(n.li,{children:"All calculations, routing, and profit distribution are done in-contract"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SwapProxy"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Wraps any DEX router to add native MEV capture capabilities"}),"\n",(0,t.jsx)(n.li,{children:"Zero external calls, zero off-chain dependencies"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"off-chain-clients",children:"Off-chain Clients"}),"\n",(0,t.jsx)(n.p,{children:"Backend and frontend systems that interact with Reflex \u2014 without ever relying on off-chain quoting, APIs, solvers, or trust assumptions. The SDK simply submits on-chain calls where all logic actually happens."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Backend trading systems"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Automated trading engines and MEV bots call the Reflex contracts directly through the SDK"}),"\n",(0,t.jsx)(n.li,{children:"All MEV extraction, backrun logic, and settlement occur on-chain with no latency"}),"\n",(0,t.jsx)(n.li,{children:"No need for off-chain quotes, no solvers, no probabilistic execution"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Frontend applications"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"DApps and interfaces provide MEV protection and aligned execution using SwapProxy"}),"\n",(0,t.jsx)(n.li,{children:"No external services, no relayers, no private RPC requirements"}),"\n",(0,t.jsx)(n.li,{children:"User flows trigger Reflex logic that executes 100% on-chain, inside the same transaction"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-principle-across-the-stack",children:"Key principle across the stack:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No external APIs"})," \u2014 No off-chain quoting or risk of stale prices"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"No trust in external solvers or builders"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No latency"})," \u2014 everything is synchronous and atomic on-chain"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Reflex guarantees that MEV protection and MEV extraction both happen under the same rules, in the same transaction, with no external dependencies."}),"\n",(0,t.jsx)(n.h2,{id:"-core-components",children:"\ud83e\udde9 Core Components"}),"\n",(0,t.jsx)(n.h3,{id:"1-reflex-router",children:"1. Reflex Router"}),"\n",(0,t.jsxs)(n.p,{children:["The central execution engine that coordinates all MEV capture activities. ",(0,t.jsx)(n.strong,{children:"One instance deployed per blockchain."})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Responsibilities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Executes MEV capture through two main entry points"}),"\n",(0,t.jsx)(n.li,{children:"Coordinates with the quoter for profitability analysis"}),"\n",(0,t.jsx)(n.li,{children:"Manages arbitrage execution for MEV capture"}),"\n",(0,t.jsx)(n.li,{children:"Handles revenue distribution to configured recipients"}),"\n",(0,t.jsx)(n.li,{children:"Maintains security through reentrancy protection"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-reflex-quoter",children:"2. Reflex Quoter"}),"\n",(0,t.jsxs)(n.p,{children:["The pricing and analysis engine that determines MEV opportunities. ",(0,t.jsx)(n.strong,{children:"One instance deployed per blockchain."})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Responsibilities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Analyzes price differences across DEX pools in real-time"}),"\n",(0,t.jsx)(n.li,{children:"Calculates optimal arbitrage routes and execution paths"}),"\n",(0,t.jsx)(n.li,{children:"Estimates gas costs and net profitability"}),"\n",(0,t.jsx)(n.li,{children:"Provides execution parameters to the router"}),"\n",(0,t.jsx)(n.li,{children:"Caches route data for efficiency"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Analysis Workflow:"})}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\n    TriggerPool[\ud83c\udfaf Trigger] --\x3e PriceCheck[\ud83d\udcca Analysis]\n    PriceCheck --\x3e RouteFind[\ud83d\udee3\ufe0f Route Discovery]\n    RouteFind --\x3e GasEst[\u26fd Gas Estimation]\n    GasEst --\x3e ProfitCalc[\ud83d\udcb0 Profit Calculation]\n    ProfitCalc --\x3e ExecutionPlan[\u26a1 Execution Parameters]"}),"\n",(0,t.jsx)(n.h3,{id:"3-reflex-backend-system-off-chain-monitoring--maintenance",children:"3. Reflex Backend System (Off-chain Monitoring & Maintenance)"}),"\n",(0,t.jsxs)(n.p,{children:["Alongside the fully onchain engine, Reflex operates a lightweight backend system designed only for monitoring, indexing, and system health \u2014 ",(0,t.jsx)(n.strong,{children:"never for execution or decision-making."})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Responsibilities:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Scans all pools and liquidity sources onchain"}),"\n",(0,t.jsx)(n.li,{children:"Automatically adds new pools and updates routing metadata"}),"\n",(0,t.jsx)(n.li,{children:"Identifies patterns, anomalies, and liquidity shifts"}),"\n",(0,t.jsx)(n.li,{children:"Monitors system liveness, execution frequency, and expected profit ranges"}),"\n",(0,t.jsx)(n.li,{children:"Ensures deployed contracts operate correctly across chains"}),"\n",(0,t.jsx)(n.li,{children:"Provides operational alerts and dashboards for integrations"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The backend never quotes, never routes, never executes trades, and never participates in MEV decisions."})}),"\n",(0,t.jsx)(n.p,{children:"Its sole purpose is observability, ensuring Reflex runs reliably and consistently at scale."}),"\n",(0,t.jsx)(n.h3,{id:"4-integration-types",children:"4. Integration Types"}),"\n",(0,t.jsx)(n.p,{children:"Reflex supports three main integration patterns:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/plugin-based",children:"Plugin-Based Integration"})})," - For DEXes with hook/plugin support. Lightweight contracts automatically trigger MEV capture after user swaps."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/universal-dex",children:"Universal DEX Integration"})})," - For any DEX and client-side applications. Uses SwapProxy + TypeScript SDK to wrap any DEX router with MEV capture."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/direct-access",children:"Direct Contract Access"})})," - For custom smart contracts. Direct calls to ",(0,t.jsx)(n.code,{children:"ReflexRouter.triggerBackrun()"})," with full control over MEV capture timing."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"./integration/overview",children:"\u2192 View Detailed Integration Guide"})}),"\n",(0,t.jsx)(n.h2,{id:"-transaction-flow",children:"\ud83d\udd04 Transaction Flow"}),"\n",(0,t.jsx)(n.h3,{id:"standard-backrun-flow",children:"Standard Backrun Flow"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant Integration as Reflex Integration<br/>(Plugin/SDK/Direct)\n    participant Router as Reflex Router\n    participant Quoter as Reflex Quoter\n\n    User->>Integration: Execute Swap\n    Integration->>Integration: Execute user swap\n    Integration->>Router: triggerBackrun()\n    Router->>Quoter: getQuote()\n    Quoter--\x3e>Router: profit estimate + route\n\n    alt Profitable Opportunity\n        Router->>Router: Execute arbitrage route\n        Router->>Router: Distribute profits to user & protocol\n    end"}),"\n",(0,t.jsx)(n.h2,{id:"-capabilities",children:"\ud83d\udca1 Capabilities"}),"\n",(0,t.jsx)(n.h3,{id:"1-slippage-correction--deterministic-arbitrage-execution",children:"1. Slippage Correction \u2014 Deterministic Arbitrage Execution"}),"\n",(0,t.jsx)(n.p,{children:"Reflex turns every swap-induced price impact into an internal arbitrage opportunity."}),"\n",(0,t.jsx)(n.p,{children:"After the user swap executes, Reflex analyzes the updated pool state, detects mispricing, and performs an optimal arbitrage backrun inside the same transaction."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"No solvers, no offchain quotes, no latency."}),(0,t.jsx)(n.br,{}),"\n","All logic is fully onchain."]}),"\n",(0,t.jsx)(n.p,{children:"This converts natural slippage into captured value: reducing user cost, rewarding LPs, and preventing external arbitrageurs from extracting profit."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Execution Flow:"})}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\n    A[\ud83d\udc64 User Swap] --\x3e B[\ud83d\udcc9 Price Impact Created<br/>real AMM state]\n    B --\x3e C[\ud83e\udde0 Onchain Mispricing Detection]\n    C --\x3e D[\u26a1 Deterministic Arbitrage Execution<br/>in-transaction]\n    D --\x3e E[\ud83d\udcb0 Profit Captured Onchain]\n    E --\x3e F[\ud83c\udf81 Value Shared With<br/>User / LPs / Treasury]"}),"\n",(0,t.jsx)(n.h3,{id:"2-sandwich-attack-prevention--structural-immunity",children:"2. Sandwich Attack Prevention \u2014 Structural Immunity"}),"\n",(0,t.jsx)(n.p,{children:"Reflex makes sandwich attacks economically impossible."}),"\n",(0,t.jsx)(n.p,{children:"A sandwich only works if the attacker can close their position after the user swap. Reflex removes this closing leg entirely by executing its own backrun inside the user's transaction, leaving no opening for attackers."}),"\n",(0,t.jsxs)(n.p,{children:["If someone front-runs the user, Reflex immediately captures the artificial imbalance they created.",(0,t.jsx)(n.br,{}),"\n","The attacker is stuck in a toxic position with no exit, and the profit flows back to the protocol."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Execution Flow:"})}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\n    A[\ud83d\ude08 Attacker Front-run] --\x3e B[\ud83d\udcca Artificial Price Distortion]\n    B --\x3e C[\ud83e\udde0 Reflex Reads Updated Pool State]\n    C --\x3e D[\u2694\ufe0f Reflex Executes Backrun<br/>Inside Transaction]\n    D --\x3e E[\ud83d\udca5 Attacker Cannot Close<br/>Holds Loss]\n    E --\x3e F[\ud83c\udf81 Protocol Captures the Profit]"}),"\n",(0,t.jsx)(n.h2,{id:"\ufe0f-security-architecture",children:"\ud83d\udee1\ufe0f Security Architecture"}),"\n",(0,t.jsx)(n.h3,{id:"reflex-security",children:"Reflex Security"}),"\n",(0,t.jsx)(n.p,{children:"Reflex implements multiple security layers to ensure safe and reliable MEV operations:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Failsafe Mechanisms"})," - Built-in safety checks that prevent execution if profitability thresholds aren't met or if gas costs exceed expected limits. All operations can be safely reverted without affecting user transactions."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Independent Operation"})," - Reflex operates completely independently from protocol and user swaps. The system has no access to user funds or protocol treasuries, only capturing MEV through legitimate arbitrage opportunities."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reentrancy Protection"})," - All router functions implement strict reentrancy guards to prevent malicious contracts from exploiting callback mechanisms during MEV executions."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Access Controls"})," - Granular permission system ensures only authorized contracts can trigger specific functions, with different access levels for plugins, direct integrations, and administrative operations."]}),"\n",(0,t.jsx)(n.h3,{id:"risk-mitigation",children:"Risk Mitigation"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reentrancy Protection"}),": Protected by reentrancy guards and callback validation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unauthorized Access"}),": Role-based permissions prevent malicious contract interactions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fund Safety"}),": No direct access to user or protocol funds - only captures public arbitrage opportunities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Failures"}),": Comprehensive failsafe mechanisms ensure failed MEV attempts don't impact user transactions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"-efficient-profit-detection",children:"\ud83d\udd27 Efficient Profit Detection"}),"\n",(0,t.jsx)(n.p,{children:"Reflex is engineered to detect and execute profitable arbitrage with minimal gas overhead."}),"\n",(0,t.jsx)(n.p,{children:"All profit checks and routing calculations are performed onchain, using a highly optimized computation path that avoids unnecessary state reads or multi-step simulations."}),"\n",(0,t.jsxs)(n.p,{children:["For a typical swap of size 1, Reflex adds only ",(0,t.jsx)(n.strong,{children:"~6% overhead"})," \u2014 an extremely low cost for real-time MEV extraction."]}),"\n",(0,t.jsx)(n.p,{children:"The execution phase may involve one or more additional swaps depending on the arbitrage route, but by the time Reflex reaches this step, profitability is already guaranteed."}),"\n",(0,t.jsxs)(n.p,{children:["In other words: ",(0,t.jsx)(n.strong,{children:"the backrun executes only when net profit (after gas) is already locked in."})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Summary:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"6% gas overhead"})," for detection and routing"]}),"\n",(0,t.jsx)(n.li,{children:"Overhead scales efficiently with swap complexity"}),"\n",(0,t.jsx)(n.li,{children:"Execution only triggers when profitability is certain"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Reflex ensures maximum MEV capture with minimal cost to users and protocols."}),"\n",(0,t.jsx)(n.h2,{id:"-multi-chain-architecture",children:"\ud83c\udf10 Multi-Chain Architecture"}),"\n",(0,t.jsx)(n.p,{children:"Reflex is designed to work across multiple blockchain networks and supported by over 180 EVM chains."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"This architecture enables Reflex to provide efficient, secure, and fair MEV capture that benefits all participants in the DeFi ecosystem. The modular design allows for easy integration with existing protocols while maintaining the flexibility to adapt to future innovations."}),"\n",(0,t.jsxs)(n.p,{children:["For implementation details, see our ",(0,t.jsx)(n.a,{href:"./integration/overview",children:"Integration Guide"})," and ",(0,t.jsx)(n.a,{href:"./api/reflex-router",children:"API Reference"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);