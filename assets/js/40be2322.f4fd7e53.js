"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[5585],{6625:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var r=t(4848),a=t(8453);const s={sidebar_position:3},i="Universal DEX Integration",o={id:"integration/universal-dex",title:"Universal DEX Integration",description:"Integrate Reflex MEV capture into any DEX and client applications using the TypeScript SDK and BackrunEnabledSwapProxy contract.",source:"@site/docs/integration/universal-dex.md",sourceDirName:"integration",slug:"/integration/universal-dex",permalink:"/reflex/integration/universal-dex",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/integration/universal-dex.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Plugin-Based Integration",permalink:"/reflex/integration/plugin-based"},next:{title:"Direct Contract Access",permalink:"/reflex/integration/direct-access"}},l={},p=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Components",id:"components",level:2},{value:"1. BackrunEnabledSwapProxy Contract",id:"1-backrunenabledswapproxy-contract",level:3},{value:"2. Reflex SDK with UniversalIntegration",id:"2-reflex-sdk-with-universalintegration",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Step 1: Deploy SwapProxy (One-time Setup)",id:"step-1-deploy-swapproxy-one-time-setup",level:3},{value:"Step 2: Install SDK",id:"step-2-install-sdk",level:3},{value:"Step 3: Initialize UniversalIntegration",id:"step-3-initialize-universalintegration",level:3},{value:"Using the Universal Integration API",id:"using-the-universal-integration-api",level:2},{value:"Basic Swap with MEV Capture",id:"basic-swap-with-mev-capture",level:3},{value:"DApp Integration",id:"dapp-integration",level:2},{value:"React Hook for Universal Integration",id:"react-hook-for-universal-integration",level:3},{value:"Helper Functions",id:"helper-functions",level:2},{value:"Check Token Approval",id:"check-token-approval",level:3},{value:"Approve Tokens",id:"approve-tokens",level:3},{value:"Estimate Gas",id:"estimate-gas",level:3},{value:"Get Addresses",id:"get-addresses",level:3},{value:"SwapProxy Deployment Guide",id:"swapproxy-deployment-guide",level:2},{value:"Deploying for Your DEX",id:"deploying-for-your-dex",level:3},{value:"Configuration and Optimization",id:"configuration-and-optimization",level:2},{value:"Gas Management",id:"gas-management",level:3},{value:"Event Monitoring",id:"event-monitoring",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Error Handling",id:"error-handling",level:3},{value:"Token Approvals",id:"token-approvals",level:3},{value:"Security",id:"security",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"universal-dex-integration",children:"Universal DEX Integration"})}),"\n",(0,r.jsxs)(n.p,{children:["Integrate Reflex MEV capture into any DEX and client applications using the TypeScript SDK and ",(0,r.jsx)(n.code,{children:"BackrunEnabledSwapProxy"})," contract."]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Universal DEX integration method enables MEV capture for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Legacy DEXes"})," that don't support hooks/plugins"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Frontend applications"})," and DApp interfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Any DEX router"})," without requiring code changes"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This approach uses a proxy contract to wrap existing DEX routers, combined with a TypeScript SDK for easy client-side integration."}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant DApp/SDK\n    participant SwapProxy\n    participant DEX Router\n    participant Reflex Router\n\n    User->>DApp/SDK: Initiate Swap\n    DApp/SDK->>SwapProxy: swapWithBackrun()\n    SwapProxy->>SwapProxy: Transfer tokens from user\n    SwapProxy->>DEX Router: Execute swap\n    DEX Router--\x3e>SwapProxy: Swap complete\n    SwapProxy->>SwapProxy: Return leftover tokens\n    SwapProxy->>Reflex Router: Trigger backrun(s)\n    Reflex Router--\x3e>SwapProxy: MEV profits\n    SwapProxy--\x3e>User: Return profits + tokens\n    DApp/SDK--\x3e>User: Display results"}),"\n",(0,r.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,r.jsx)(n.h3,{id:"1-backrunenabledswapproxy-contract",children:"1. BackrunEnabledSwapProxy Contract"}),"\n",(0,r.jsx)(n.p,{children:"A smart contract that wraps any existing DEX router and adds MEV capture functionality."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Works with any DEX router (Uniswap, SushiSwap, PancakeSwap, etc.)"}),"\n",(0,r.jsx)(n.li,{children:"Atomic swap + backrun execution"}),"\n",(0,r.jsx)(n.li,{children:"Automatic token approval management"}),"\n",(0,r.jsx)(n.li,{children:"Returns leftover tokens and ETH to users"}),"\n",(0,r.jsx)(n.li,{children:"Reentrancy protected"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Deployment:"}),"\nOne proxy contract per target DEX router you want to support."]}),"\n",(0,r.jsx)(n.h3,{id:"2-reflex-sdk-with-universalintegration",children:"2. Reflex SDK with UniversalIntegration"}),"\n",(0,r.jsx)(n.p,{children:"A client-side library that simplifies interaction with the SwapProxy and Reflex contracts."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Type-safe interfaces matching contract exactly"}),"\n",(0,r.jsx)(n.li,{children:"Automatic token approval helpers"}),"\n",(0,r.jsx)(n.li,{children:"Gas estimation"}),"\n",(0,r.jsx)(n.li,{children:"Multi-chain support"}),"\n",(0,r.jsx)(n.li,{children:"Built on ethers.js v6"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,r.jsx)(n.h3,{id:"step-1-deploy-swapproxy-one-time-setup",children:"Step 1: Deploy SwapProxy (One-time Setup)"}),"\n",(0,r.jsxs)(n.p,{children:["Deploy a ",(0,r.jsx)(n.code,{children:"BackrunEnabledSwapProxy"})," contract for your target DEX router:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// Deploy via Foundry script or directly\nimport {BackrunEnabledSwapProxy} from "@reflex/contracts/integrations/router/BackrunEnabledSwapProxy.sol";\n\n// Constructor takes the target DEX router address\nBackrunEnabledSwapProxy proxy = new BackrunEnabledSwapProxy(\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D  // Uniswap V2 Router\n);\n'})}),"\n",(0,r.jsx)(n.p,{children:"Or use the provided deployment script:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Set environment variables\nexport TARGET_ROUTER_ADDRESS=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n\n# Deploy\nforge script script/deploy-swap-proxy/DeployBackrunEnabledSwapProxy.s.sol \\\n    --rpc-url <YOUR_RPC_URL> \\\n    --private-key <YOUR_PRIVATE_KEY> \\\n    --broadcast\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-2-install-sdk",children:"Step 2: Install SDK"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @reflex-mev/sdk ethers\n# or\nyarn add @reflex-mev/sdk ethers\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-initialize-universalintegration",children:"Step 3: Initialize UniversalIntegration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\nimport { ethers } from "ethers";\n\n// Initialize provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  "https://mainnet.infura.io/v3/YOUR_KEY"\n);\nconst signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);\n\n// Create UniversalIntegration instance\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  "0xYourSwapProxyAddress", // SwapProxy contract address\n  "0xYourReflexRouterAddress" // Reflex Router address\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"using-the-universal-integration-api",children:"Using the Universal Integration API"}),"\n",(0,r.jsx)(n.h3,{id:"basic-swap-with-mev-capture",children:"Basic Swap with MEV Capture"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\nimport { ethers } from "ethers";\n\n// Initialize integration\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  swapProxyAddress,\n  reflexRouterAddress\n);\n\n// Encode swap calldata for target DEX router\n// Example: Uniswap V2 swapExactTokensForTokens\nconst targetDexInterface = new ethers.Interface([\n  "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)",\n]);\n\nconst swapCalldata = targetDexInterface.encodeFunctionData(\n  "swapExactTokensForTokens",\n  [\n    ethers.parseEther("1.0"), // amountIn\n    ethers.parseEther("0.95"), // amountOutMin (with slippage)\n    [tokenInAddress, tokenOutAddress], // path\n    userAddress, // to\n    Math.floor(Date.now() / 1000) + 60 * 20, // deadline (20 min)\n  ]\n);\n\n// Prepare swap metadata\nconst swapMetadata = {\n  swapTxCallData: swapCalldata,\n  tokenIn: tokenInAddress,\n  amountIn: ethers.parseEther("1.0"),\n  tokenOut: tokenOutAddress,\n  recipient: userAddress,\n};\n\n// Prepare backrun parameters\nconst backrunParams = [\n  {\n    triggerPoolId: poolAddress, // Pool being traded on\n    swapAmountIn: ethers.parseEther("1.0"), // Full swap amount\n    token0In: true, // Swap direction\n    recipient: userAddress,\n    configId: ethers.ZeroHash, // Use default config\n  },\n];\n\n// Approve tokens to SwapProxy first\nawait integration.approveTokens([\n  {\n    tokenAddress: tokenInAddress,\n    amount: ethers.parseEther("1.0"),\n  },\n]);\n\n// Execute swap with automatic MEV capture\nconst result = await integration.swapWithBackrun(\n  swapCalldata,\n  swapMetadata,\n  backrunParams,\n  { gasLimit: 1500000n } // Optional: ethers Overrides\n);\n\nconsole.log("Transaction:", result.transactionHash);\nconsole.log("Gas used:", result.gasUsed.toString());\nconsole.log("Profits:", result.profits);\nconsole.log("Profit tokens:", result.profitTokens);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"dapp-integration",children:"DApp Integration"}),"\n",(0,r.jsx)(n.h3,{id:"react-hook-for-universal-integration",children:"React Hook for Universal Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { useState, useEffect, useCallback } from "react";\nimport { ethers } from "ethers";\nimport { UniversalIntegration } from "@reflex-mev/sdk/integrations";\n\nexport function useReflexSwap(\n  provider,\n  signer,\n  swapProxyAddress,\n  reflexRouterAddress\n) {\n  const [integration, setIntegration] = useState(null);\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    if (provider && signer && swapProxyAddress && reflexRouterAddress) {\n      const instance = new UniversalIntegration(\n        provider,\n        signer,\n        swapProxyAddress,\n        reflexRouterAddress\n      );\n      setIntegration(instance);\n      setIsReady(true);\n    }\n  }, [provider, signer, swapProxyAddress, reflexRouterAddress]);\n\n  const executeSwapWithMEV = useCallback(\n    async (swapParams) => {\n      if (!integration || !isReady) {\n        throw new Error("UniversalIntegration not initialized");\n      }\n\n      try {\n        // Encode the swap call for the target DEX\n        const targetDexInterface = new ethers.Interface([\n          "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)",\n        ]);\n\n        const swapCalldata = targetDexInterface.encodeFunctionData(\n          "swapExactTokensForTokens",\n          [\n            swapParams.amountIn,\n            swapParams.amountOutMin,\n            swapParams.path,\n            swapParams.recipient,\n            Math.floor(Date.now() / 1000) + 60 * 20, // 20 min deadline\n          ]\n        );\n\n        // Prepare swap metadata\n        const swapMetadata = {\n          swapTxCallData: swapCalldata,\n          tokenIn: swapParams.tokenIn,\n          amountIn: swapParams.amountIn,\n          tokenOut: swapParams.tokenOut,\n          recipient: swapParams.recipient,\n        };\n\n        // Prepare backrun parameters\n        const backrunParams = [\n          {\n            triggerPoolId: swapParams.poolAddress,\n            swapAmountIn: swapParams.amountIn, // Full swap amount\n            token0In: swapParams.tokenIn < swapParams.tokenOut,\n            recipient: swapParams.recipient,\n            configId: swapParams.configId || ethers.ZeroHash,\n          },\n        ];\n\n        // Check and handle token approval\n        const isApproved = await integration.isTokenApproved(\n          swapParams.tokenIn,\n          swapParams.amountIn\n        );\n\n        if (!isApproved) {\n          await integration.approveTokens([\n            {\n              tokenAddress: swapParams.tokenIn,\n              amount: ethers.MaxUint256, // Approve unlimited for better UX\n            },\n          ]);\n        }\n\n        // Execute swap with MEV capture\n        const result = await integration.swapWithBackrun(\n          swapCalldata,\n          swapMetadata,\n          backrunParams,\n          { value: swapParams.ethValue || 0n }\n        );\n\n        return {\n          success: true,\n          transactionHash: result.transactionHash,\n          gasUsed: result.gasUsed,\n          profits: result.profits,\n          profitTokens: result.profitTokens,\n          swapReturnData: result.swapReturnData,\n        };\n      } catch (error) {\n        console.error("Swap with MEV failed:", error);\n        throw error;\n      }\n    },\n    [integration, isReady]\n  );\n\n  return {\n    integration,\n    executeSwapWithMEV,\n    isReady,\n  };\n}\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'\n### Trading Interface Component\n\n```typescript\nimport React, { useState } from "react";\nimport { ethers } from "ethers";\n\nexport function MEVTradingInterface({\n  provider,\n  signer,\n  swapProxyAddress,\n  reflexRouterAddress\n}) {\n  const { integration, executeSwapWithMEV, isReady } = useReflexSwap(\n    provider,\n    signer,\n    swapProxyAddress,\n    reflexRouterAddress\n  );\n\n  const [swapAmount, setSwapAmount] = useState("");\n  const [isSwapping, setIsSwapping] = useState(false);\n  const [selectedTokenIn, setSelectedTokenIn] = useState(null);\n  const [selectedTokenOut, setSelectedTokenOut] = useState(null);\n\n  const handleSwap = async () => {\n    if (!selectedTokenIn || !selectedTokenOut) {\n      alert("Please select tokens");\n      return;\n    }\n\n    setIsSwapping(true);\n\n    try {\n      const result = await executeSwapWithMEV({\n        tokenIn: selectedTokenIn.address,\n        tokenOut: selectedTokenOut.address,\n        amountIn: ethers.parseUnits(swapAmount, selectedTokenIn.decimals),\n        amountOutMin: 0n, // Set appropriate slippage\n        path: [selectedTokenIn.address, selectedTokenOut.address],\n        poolAddress: "0xPoolAddress", // The pool being traded on\n        recipient: await signer.getAddress(),\n        configId: ethers.ZeroHash, // Use default config\n        ethValue: 0n // Set if swap involves ETH\n      });\n\n      if (result.success) {\n        showNotification({\n          type: "success",\n          title: "Swap Completed!",\n          message: `Transaction: ${result.transactionHash.slice(0, 10)}...`,\n          details: `Gas used: ${result.gasUsed.toString()}`\n        });\n\n        // Check if MEV was captured\n        if (result.profits.length > 0 && result.profits[0] > 0n) {\n          showNotification({\n            type: "success",\n            title: "MEV Bonus Captured!",\n            message: `You received an additional ${ethers.formatEther(\n              result.profits[0]\n            )} tokens from MEV`\n          });\n        }\n      }\n    } catch (error) {\n      showNotification({\n        type: "error",\n        title: "Swap Failed",\n        message: error.message\n      });\n    } finally {\n      setIsSwapping(false);\n    }\n  };\n\n  return (\n    <div className="trading-interface">\n      <h2>Swap with MEV Protection</h2>\n\n      {/* Token Selection */}\n      <div className="token-inputs">\n        <input\n          type="number"\n          value={swapAmount}\n          onChange={(e) => setSwapAmount(e.target.value)}\n          placeholder="Amount to swap"\n        />\n        {/* Add token selectors here */}\n      </div>\n\n      {/* Swap Button */}\n      <button\n        onClick={handleSwap}\n        disabled={!isReady || isSwapping || !swapAmount}\n        className="swap-button"\n      >\n        {isSwapping ? "Swapping..." : "Swap with MEV Capture"}\n      </button>\n\n      {/* Info */}\n      <div className="swap-info">\n        <p>\u2705 Automatic MEV capture enabled</p>\n        <p>\u2705 Protected from sandwich attacks</p>\n        <p>\u2705 Profits returned to you</p>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"helper-functions",children:"Helper Functions"}),"\n",(0,r.jsx)(n.h3,{id:"check-token-approval",children:"Check Token Approval"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Check if token is approved before swapping\nconst isApproved = await integration.isTokenApproved(tokenAddress, amount);\n\nif (!isApproved) {\n  console.log("Approval needed");\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"approve-tokens",children:"Approve Tokens"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Approve single token\nawait integration.approveTokens([\n  {\n    tokenAddress: USDC_ADDRESS,\n    amount: ethers.MaxUint256, // Unlimited approval\n  },\n]);\n\n// Approve multiple tokens\nawait integration.approveTokens([\n  {\n    tokenAddress: USDC_ADDRESS,\n    amount: ethers.parseUnits("100", 6),\n  },\n  {\n    tokenAddress: WETH_ADDRESS,\n    amount: ethers.parseEther("1.0"),\n  },\n]);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"estimate-gas",children:"Estimate Gas"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Estimate gas before executing\nconst estimatedGas = await integration.estimateGas(\n  swapCalldata,\n  swapMetadata,\n  backrunParams\n);\n\nconsole.log("Estimated gas:", estimatedGas.toString());\n\n// Use estimate with buffer\nconst result = await integration.swapWithBackrun(\n  swapCalldata,\n  swapMetadata,\n  backrunParams,\n  { gasLimit: estimatedGas } // Estimate already includes 20% buffer\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"get-addresses",children:"Get Addresses"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Get SwapProxy address\nconst swapProxyAddress = integration.getSwapProxyAddress();\n\n// Get ReflexRouter address\nconst routerAddress = integration.getReflexRouterAddress();\n\n// Get target DEX router address\nconst targetRouterAddress = await integration.getTargetRouterAddress();\n"})}),"\n",(0,r.jsx)(n.h2,{id:"swapproxy-deployment-guide",children:"SwapProxy Deployment Guide"}),"\n",(0,r.jsx)(n.h3,{id:"deploying-for-your-dex",children:"Deploying for Your DEX"}),"\n",(0,r.jsx)(n.p,{children:"Deploy a SwapProxy for each DEX router you want to support:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Clone the Reflex repository\ngit clone --recursive https://github.com/reflex-mev/reflex.git\ncd reflex/core\n\n# Set environment variables\nexport TARGET_ROUTER_ADDRESS=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D  # Uniswap V2 Router\n\n# Deploy using Forge\nforge script script/deploy-swap-proxy/DeployBackrunEnabledSwapProxy.s.sol \\\n    --rpc-url $RPC_URL \\\n    --private-key $PRIVATE_KEY \\\n    --broadcast \\\n    --verify\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-and-optimization",children:"Configuration and Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"gas-management",children:"Gas Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Use ethers Overrides for transaction options\nconst result = await integration.swapWithBackrun(\n  swapCalldata,\n  swapMetadata,\n  backrunParams,\n  {\n    gasLimit: 1500000n, // Recommended for MEV operations\n    maxFeePerGas: ethers.parseUnits("100", "gwei"),\n    maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"),\n  }\n);\n'})}),"\n",(0,r.jsx)(n.h3,{id:"event-monitoring",children:"Event Monitoring"}),"\n",(0,r.jsx)(n.p,{children:"Monitor MEV capture events from the Reflex Router:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Event monitoring through provider\nimport { Interface } from "ethers";\nimport { REFLEX_ROUTER_ABI } from "@reflex-mev/sdk";\n\nconst routerInterface = new Interface(REFLEX_ROUTER_ABI);\n\n// Listen for BackrunExecuted events\nprovider.on(\n  {\n    address: reflexRouterAddress,\n    topics: [routerInterface.getEvent("BackrunExecuted").topicHash],\n  },\n  (log) => {\n    const event = routerInterface.parseLog(log);\n\n    console.log("MEV Captured!", {\n      profit: ethers.formatEther(event.args.profit),\n      profitToken: event.args.profitToken,\n      triggerPoolId: event.args.triggerPoolId,\n      recipient: event.args.recipient,\n    });\n\n    // Update UI or analytics\n    analytics.track("MEV_Captured", {\n      profit: event.args.profit,\n      timestamp: Date.now(),\n    });\n  }\n);\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'async function safeSwapWithMEV(swapParams) {\n  try {\n    const result = await executeSwapWithMEV(swapParams);\n    return result;\n  } catch (error) {\n    // Check for specific error types\n    if (error.code === "INSUFFICIENT_FUNDS") {\n      showError("Insufficient balance for this swap");\n    } else if (error.code === "USER_REJECTED") {\n      showError("Transaction cancelled by user");\n    } else if (error.message.includes("slippage")) {\n      showError("Price moved too much. Try increasing slippage tolerance");\n    } else {\n      // Log unexpected errors\n      console.error("Swap failed:", error);\n      showError("Swap failed. Please try again");\n    }\n    return null;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"token-approvals",children:"Token Approvals"}),"\n",(0,r.jsx)(n.p,{children:"Use the built-in approval helpers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Check approval first\nconst isApproved = await integration.isTokenApproved(tokenAddress, amount);\n\nif (!isApproved) {\n  // Approve with unlimited amount for better UX\n  await integration.approveTokens([\n    {\n      tokenAddress,\n      amount: ethers.MaxUint256,\n    },\n  ]);\n}\n\n// Or approve exact amount for security\nawait integration.approveTokens([\n  {\n    tokenAddress,\n    amount: exactAmount,\n  },\n]);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"security",children:"Security"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Never expose private keys"})," in frontend code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate all user inputs"})," before sending transactions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use secure RPC endpoints"})," (avoid public endpoints in production)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement rate limiting"})," to prevent abuse"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Set reasonable slippage tolerances"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check contract addresses"})," before interacting"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"The Universal DEX integration provides:"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Universal DEX Support"})," - Works with any DEX router without modifications",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Type-Safe SDK"})," - UniversalIntegration class with full TypeScript support",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Simple API"})," - Clean interface matching contract exactly",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Atomic Execution"})," - Swap + MEV capture in single transaction",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Built-in Helpers"})," - Token approvals, gas estimation, address getters",(0,r.jsx)(n.br,{}),"\n","\u2705 ",(0,r.jsx)(n.strong,{children:"Production Ready"})," - Tested and secure implementation"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Next Steps:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./direct-access",children:"View Direct Contract Access"})," - For custom protocol integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./plugin-based",children:"View Plugin-Based Integration"})," - For DEXes with hook support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../architecture",children:"Read Architecture Guide"})," - Understand system design"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);