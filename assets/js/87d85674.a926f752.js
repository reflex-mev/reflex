"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[620],{5608:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=t(4848),r=t(8453);const o={sidebar_position:2},s="Smart Contract Integration",a={id:"integration/smart-contract",title:"Smart Contract Integration",description:"Integrate Reflex MEV capture directly into your smart contracts using either router direct access or plugin-based architecture.",source:"@site/docs/integration/smart-contract.md",sourceDirName:"integration",slug:"/integration/smart-contract",permalink:"/reflex/integration/smart-contract",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/integration/smart-contract.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Revenue Configuration",permalink:"/reflex/integration/revenue-configuration"},next:{title:"SDK Integration",permalink:"/reflex/integration/sdk-integration"}},l={},c=[{value:"Router Direct Access",id:"router-direct-access",level:2},{value:"Overview",id:"overview",level:3},{value:"Implementation",id:"implementation",level:3},{value:"1. Import Reflex Interface",id:"1-import-reflex-interface",level:4},{value:"2. Trigger Backruns",id:"2-trigger-backruns",level:4},{value:"3. Revenue Configuration",id:"3-revenue-configuration",level:4},{value:"Plugin-Based Access",id:"plugin-based-access",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Algebra-Based Plugin",id:"algebra-based-plugin",level:3},{value:"Integration with Existing Pools",id:"integration-with-existing-pools",level:3},{value:"Modify Pool Contract",id:"modify-pool-contract",level:4},{value:"Factory Integration",id:"factory-integration",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Gas Optimization",id:"gas-optimization",level:3},{value:"Monitoring",id:"monitoring",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"smart-contract-integration",children:"Smart Contract Integration"})}),"\n",(0,i.jsx)(n.p,{children:"Integrate Reflex MEV capture directly into your smart contracts using either router direct access or plugin-based architecture."}),"\n",(0,i.jsx)(n.h2,{id:"router-direct-access",children:"Router Direct Access"}),"\n",(0,i.jsx)(n.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Direct integration with the Reflex Router gives you complete control over MEV capture timing and logic. This approach is ideal for new protocols or when you want tight integration with your core contract logic."}),"\n",(0,i.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.h4,{id:"1-import-reflex-interface",children:"1. Import Reflex Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/interfaces/IReflexRouter.sol";\n\ncontract YourProtocol {\n    IReflexRouter public immutable reflexRouter;\n\n    constructor(address _reflexRouter) {\n        reflexRouter = IReflexRouter(_reflexRouter);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"2-trigger-backruns",children:"2. Trigger Backruns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"function executeSwapWithMEV(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    bytes32 configId\n) external {\n    // Execute your core swap logic\n    uint256 amountOut = _executeSwap(tokenIn, tokenOut, amountIn);\n\n    // Trigger MEV capture\n    try reflexRouter.triggerBackrun(\n        bytes32(uint256(uint160(address(this)))), // Pool identifier\n        uint112(amountIn / 20), // 5% of swap for backrun\n        tokenIn < tokenOut, // Token order\n        msg.sender, // Profit recipient\n        configId // Revenue sharing config\n    ) returns (uint256 profit, address profitToken) {\n        emit MEVCaptured(msg.sender, profit, profitToken);\n    } catch {\n        // MEV capture failed, continue normal operation\n        emit MEVCaptureFailed(msg.sender, amountIn);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"3-revenue-configuration",children:"3. Revenue Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["Revenue sharing configurations are managed by the Reflex Protocol team. For detailed information on how to set up custom revenue sharing, see the ",(0,i.jsx)(n.a,{href:"./revenue-configuration",children:"Revenue Configuration Guide"}),"."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Quick Summary:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Contact Reflex Protocol"})," with your desired revenue sharing structure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Receive your configId"})," after configuration is set up by the Reflex team"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use the configId"})," in your contract calls"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract YourProtocol {\n    // ConfigId provided by Reflex Protocol team\n    bytes32 public immutable CONFIG_ID;\n\n    constructor(address _reflexRouter, bytes32 _configId) {\n        reflexRouter = IReflexRouter(_reflexRouter);\n        CONFIG_ID = _configId;\n    }\n\n    function executeSwapWithCustomConfig(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external {\n        // Execute your core swap logic\n        uint256 amountOut = _executeSwap(tokenIn, tokenOut, amountIn);\n\n        // Use your custom configId\n        reflexRouter.triggerBackrun(\n            bytes32(uint256(uint160(address(this)))),\n            uint112(amountIn / 20),\n            tokenIn < tokenOut,\n            msg.sender,\n            CONFIG_ID // Your custom config provided by Reflex\n        );\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"plugin-based-access",children:"Plugin-Based Access"}),"\n",(0,i.jsx)(n.h3,{id:"overview-1",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Plugin-based integration uses lightweight contracts that hook into your existing DEX architecture. This is perfect for protocols that already have callback systems or want minimal changes to existing code."}),"\n",(0,i.jsx)(n.h3,{id:"algebra-based-plugin",children:"Algebra-Based Plugin"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract AlgebraReflexPlugin is ReflexAfterSwap {\n    struct PluginConfig {\n        uint256 minThreshold;\n        uint256 backrunRatio; // Basis points\n        bool enabled;\n        mapping(address => bool) excludedUsers;\n    }\n\n    PluginConfig public config;\n    bytes32 public immutable CONFIG_ID;\n\n    constructor(\n        address _reflexRouter,\n        address _pool,\n        bytes32 _configId\n    ) ReflexAfterSwap(_reflexRouter, _pool) {\n        config.minThreshold = 1e18;\n        config.backrunRatio = 500; // 5%\n        config.enabled = true;\n        CONFIG_ID = _configId;\n    }\n\n    function afterSwap(\n        address sender,\n        int256 amount0,\n        int256 amount1,\n        uint160 currentPrice,\n        uint128 currentLiquidity,\n        int24 currentTick,\n        bytes calldata data\n    ) external override onlyPool {\n        if (!config.enabled || config.excludedUsers[sender]) {\n            return;\n        }\n\n        uint256 swapAmount = amount0 > 0 ? uint256(amount0) : uint256(-amount1);\n\n        if (swapAmount >= config.minThreshold) {\n            uint256 backrunAmount = (swapAmount * config.backrunRatio) / 10000;\n\n            try reflexRouter.triggerBackrun(\n                bytes32(uint256(uint160(pool))),\n                uint112(backrunAmount),\n                amount0 > 0,\n                sender,\n                CONFIG_ID\n            ) returns (uint256 profit, address profitToken) {\n                emit MEVCaptured(sender, profit, profitToken);\n            } catch {\n                emit MEVCaptureFailed(sender, backrunAmount);\n            }\n        }\n    }\n\n    // Admin functions\n    function updateConfig(\n        uint256 _minThreshold,\n        uint256 _backrunRatio,\n        bool _enabled\n    ) external onlyOwner {\n        config.minThreshold = _minThreshold;\n        config.backrunRatio = _backrunRatio;\n        config.enabled = _enabled;\n    }\n\n    function excludeUser(address user, bool excluded) external onlyOwner {\n        config.excludedUsers[user] = excluded;\n    }\n\n    // Events\n    event MEVCaptured(address indexed user, uint256 profit, address profitToken);\n    event MEVCaptureFailed(address indexed user, uint256 attemptedAmount);\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"integration-with-existing-pools",children:"Integration with Existing Pools"}),"\n",(0,i.jsx)(n.h4,{id:"modify-pool-contract",children:"Modify Pool Contract"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'contract YourPool {\n    address public reflexPlugin;\n\n    modifier withMEVCapture() {\n        _;\n        if (reflexPlugin != address(0)) {\n            try IReflexPlugin(reflexPlugin).afterSwap(\n                msg.sender,\n                amount0Out,\n                amount1Out,\n                ""\n            ) {} catch {\n                // Plugin failed, continue normal operation\n            }\n        }\n    }\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external withMEVCapture {\n        // Your existing swap logic\n        _swap(amount0Out, amount1Out, to, data);\n    }\n\n    function setReflexPlugin(address _plugin) external onlyOwner {\n        reflexPlugin = _plugin;\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"factory-integration",children:"Factory Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract YourPoolFactory {\n    address public immutable reflexRouter;\n    mapping(address => address) public poolPlugins;\n    bytes32 public immutable defaultConfigId;\n\n    constructor(address _reflexRouter, bytes32 _defaultConfigId) {\n        reflexRouter = _reflexRouter;\n        defaultConfigId = _defaultConfigId;\n    }\n\n    function createPoolWithMEV(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool, address plugin) {\n        // Create pool\n        pool = _createPool(tokenA, tokenB, fee);\n\n        // Deploy Algebra plugin with default config\n        plugin = new AlgebraReflexPlugin(\n            reflexRouter,\n            pool,\n            defaultConfigId\n        );\n\n        // Configure pool to use plugin\n        IYourPool(pool).setReflexPlugin(plugin);\n\n        poolPlugins[pool] = plugin;\n\n        emit PoolCreatedWithMEV(pool, plugin);\n    }\n\n    function createPoolWithCustomConfig(\n        address tokenA,\n        address tokenB,\n        uint24 fee,\n        bytes32 customConfigId\n    ) external returns (address pool, address plugin) {\n        // Create pool\n        pool = _createPool(tokenA, tokenB, fee);\n\n        // Deploy plugin with custom config (provided by Reflex team)\n        plugin = new AlgebraReflexPlugin(\n            reflexRouter,\n            pool,\n            customConfigId\n        );\n\n        // Configure pool to use plugin\n        IYourPool(pool).setReflexPlugin(plugin);\n\n        poolPlugins[pool] = plugin;\n\n        emit PoolCreatedWithMEV(pool, plugin);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Always use try/catch"})," when calling Reflex functions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validate all inputs"})," before triggering MEV capture"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set reasonable thresholds"})," to prevent spam"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement access controls"})," for configuration functions"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache frequently used values"})," like config IDs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use appropriate data types"})," (uint112 for amounts)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimize external calls"})," in hot paths"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consider batch operations"})," for multiple triggers"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Emit events"})," for all MEV capture attempts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Track success/failure rates"})," in your analytics"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Monitor gas usage"})," patterns"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Set up alerts"})," for unusual activity"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:["For revenue configuration details, see the ",(0,i.jsx)(n.a,{href:"./revenue-configuration",children:"Revenue Configuration Guide"}),".\nFor SDK integration, see the ",(0,i.jsx)(n.a,{href:"./sdk-integration",children:"SDK Integration Guide"}),".\nFor SDK integration details, see the ",(0,i.jsx)(n.a,{href:"./sdk-integration",children:"SDK Integration Guide"}),"."]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);