"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[309],{8305:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=t(4848),r=t(8453);const o={sidebar_position:1},s="Integration Overview",a={id:"technical/integration/overview",title:"Integration Overview",description:"Learn how to integrate Reflex Protocol into your DeFi protocol to capture and distribute MEV fairly among your users.",source:"@site/docs/technical/integration/overview.md",sourceDirName:"technical/integration",slug:"/technical/integration/overview",permalink:"/reflex/technical/integration/overview",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/technical/integration/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Architecture Overview",permalink:"/reflex/technical/architecture/overview"},next:{title:"Smart Contract Integration",permalink:"/reflex/technical/integration/smart-contract"}},l={},c=[{value:"\ud83c\udfaf Integration Types",id:"-integration-types",level:2},{value:"1. Smart Contract Integration",id:"1-smart-contract-integration",level:2},{value:"Router Direct Access",id:"router-direct-access",level:3},{value:"Plugin-Based Access",id:"plugin-based-access",level:3},{value:"2. SDK Integration",id:"2-sdk-integration",level:2},{value:"TypeScript SDK",id:"typescript-sdk",level:3},{value:"\ud83d\udd0c Plugin Integration Guide",id:"-plugin-integration-guide",level:2},{value:"Step 1: Choose Your Plugin Type",id:"step-1-choose-your-plugin-type",level:3},{value:"UniswapV2-Style Plugin",id:"uniswapv2-style-plugin",level:4},{value:"UniswapV3-Style Plugin",id:"uniswapv3-style-plugin",level:4},{value:"Step 2: Deploy Your Plugin",id:"step-2-deploy-your-plugin",level:3},{value:"Step 3: Configure Revenue Sharing",id:"step-3-configure-revenue-sharing",level:3},{value:"Step 4: Integrate the Plugin",id:"step-4-integrate-the-plugin",level:3},{value:"Option A: Modify Existing Pool Contract",id:"option-a-modify-existing-pool-contract",level:4},{value:"Option B: Use Factory Pattern",id:"option-b-use-factory-pattern",level:4},{value:"\ud83d\udcf1 SDK Integration Guide",id:"-sdk-integration-guide",level:2},{value:"Step 1: Install and Initialize",id:"step-1-install-and-initialize",level:3},{value:"Step 2: Monitor and Execute",id:"step-2-monitor-and-execute",level:3},{value:"Step 3: Advanced Strategies",id:"step-3-advanced-strategies",level:3},{value:"\ud83d\udd27 Testing Your Integration",id:"-testing-your-integration",level:2},{value:"Unit Tests",id:"unit-tests",level:3},{value:"Integration Tests",id:"integration-tests",level:3},{value:"\ud83d\udcca Monitoring and Analytics",id:"-monitoring-and-analytics",level:2},{value:"Event Monitoring",id:"event-monitoring",level:3},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"\ud83d\ude80 Deployment Checklist",id:"-deployment-checklist",level:2},{value:"\ud83c\udd98 Common Issues and Solutions",id:"-common-issues-and-solutions",level:2},{value:"Issue: Plugin Not Triggering",id:"issue-plugin-not-triggering",level:3},{value:"Issue: Backruns Always Failing",id:"issue-backruns-always-failing",level:3},{value:"Issue: No Profits Being Distributed",id:"issue-no-profits-being-distributed",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",input:"input",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"integration-overview",children:"Integration Overview"})}),"\n",(0,i.jsx)(e.p,{children:"Learn how to integrate Reflex Protocol into your DeFi protocol to capture and distribute MEV fairly among your users."}),"\n",(0,i.jsx)(e.h2,{id:"-integration-types",children:"\ud83c\udfaf Integration Types"}),"\n",(0,i.jsx)(e.p,{children:"Reflex offers two main integration approaches depending on your use case and technical requirements:"}),"\n",(0,i.jsx)(e.h2,{id:"1-smart-contract-integration",children:"1. Smart Contract Integration"}),"\n",(0,i.jsx)(e.p,{children:"For protocols and DEXs that want to integrate MEV capture directly into their smart contracts."}),"\n",(0,i.jsx)(e.h3,{id:"router-direct-access",children:"Router Direct Access"}),"\n",(0,i.jsx)(e.p,{children:"Integrate directly with the Reflex Router for full control over MEV capture:"}),"\n",(0,i.jsx)(e.mermaid,{value:"graph LR\n    Protocol[\ud83c\udfdb\ufe0f Your Protocol] --\x3e Router[\ud83c\udfaf Reflex Router]\n    Router --\x3e |MEV Capture| Protocol"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Best for:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u2705 New protocol development"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Deep MEV integration"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Custom revenue models"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Protocol-level optimization"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"How it works:"}),"\nYour smart contract calls the Reflex Router directly to trigger backrun opportunities. This gives you complete control over when and how MEV is captured."]}),"\n",(0,i.jsx)(e.h3,{id:"plugin-based-access",children:"Plugin-Based Access"}),"\n",(0,i.jsx)(e.p,{children:"Deploy a lightweight plugin contract that automatically captures MEV from swaps:"}),"\n",(0,i.jsx)(e.mermaid,{value:"graph LR\n    User[\ud83d\udc64 User] --\x3e DEX[\ud83c\udfea Your DEX]\n    DEX --\x3e Plugin[\ud83d\udd0c Reflex Plugin]\n    Plugin --\x3e Router[\ud83c\udfaf Reflex Router]\n    Router --\x3e |Profits| User"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Best for:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u2705 Existing DEX protocols"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Minimal code changes required"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Automatic MEV capture"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Hook/callback architectures"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"How it works:"}),"\nA plugin contract integrates with your existing DEX using hooks or callbacks (like ",(0,i.jsx)(e.code,{children:"afterSwap"}),"). When users trade, the plugin automatically triggers MEV capture opportunities."]}),"\n",(0,i.jsx)(e.h2,{id:"2-sdk-integration",children:"2. SDK Integration"}),"\n",(0,i.jsx)(e.p,{children:"For clients, DApps, and custom applications that want to integrate MEV capture functionality."}),"\n",(0,i.jsx)(e.h3,{id:"typescript-sdk",children:"TypeScript SDK"}),"\n",(0,i.jsx)(e.p,{children:"Use the TypeScript SDK for custom MEV strategies and manual triggers:"}),"\n",(0,i.jsx)(e.mermaid,{value:"graph LR\n    DApp[\ud83d\udcf1 Your DApp] --\x3e SDK[\ud83d\udce6 Reflex SDK]\n    SDK --\x3e Router[\ud83c\udfaf Reflex Router]\n    Router --\x3e |Results| DApp"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Best for:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u2705 Frontend applications"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 MEV bots and searchers"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Custom trading strategies"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Multi-chain operations"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Advanced profit optimization"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"How it works:"}),"\nYour application uses the Reflex SDK to monitor transactions, detect MEV opportunities, and execute backruns programmatically. Perfect for building sophisticated MEV strategies or integrating MEV capture into user-facing applications."]}),"\n",(0,i.jsx)(e.p,{children:"Directly integrate Reflex contracts into your protocol's core logic:"}),"\n",(0,i.jsx)(e.mermaid,{value:"graph LR\n    Protocol[\ud83c\udfdb\ufe0f Your Protocol] --\x3e Router[\ud83c\udfaf Reflex Router]\n    Router --\x3e |MEV Capture| Protocol"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Best for:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u2705 New protocol development"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Deep MEV integration"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Custom revenue models"}),"\n",(0,i.jsx)(e.li,{children:"\u2705 Protocol-level optimization"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"-plugin-integration-guide",children:"\ud83d\udd0c Plugin Integration Guide"}),"\n",(0,i.jsx)(e.h3,{id:"step-1-choose-your-plugin-type",children:"Step 1: Choose Your Plugin Type"}),"\n",(0,i.jsx)(e.h4,{id:"uniswapv2-style-plugin",children:"UniswapV2-Style Plugin"}),"\n",(0,i.jsxs)(e.p,{children:["For AMMs with ",(0,i.jsx)(e.code,{children:"swap()"})," callbacks:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract UniV2Plugin is ReflexAfterSwap {\n    uint256 public constant MIN_BACKRUN_THRESHOLD = 1e18; // 1 token\n    bytes32 public immutable CONFIG_ID;\n\n    constructor(\n        address _reflexRouter,\n        address _pool,\n        bytes32 _configId\n    ) ReflexAfterSwap(_reflexRouter, _pool) {\n        CONFIG_ID = _configId;\n    }\n\n    function afterSwap(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override onlyPool {\n        uint256 swapAmount = amount0 > 0 ? amount0 : amount1;\n        bool token0In = amount0 > 0;\n\n        // Only trigger for significant swaps\n        if (swapAmount >= MIN_BACKRUN_THRESHOLD) {\n            try reflexRouter.triggerBackrun(\n                bytes32(uint256(uint160(pool))), // Pool as trigger ID\n                uint112(swapAmount / 20),        // 5% of swap amount\n                token0In,\n                sender,                          // Profit to original swapper\n                CONFIG_ID\n            ) returns (uint256 profit, address profitToken) {\n                emit BackrunTriggered(sender, profit, profitToken);\n            } catch {\n                // Failed backruns are ignored\n                emit BackrunFailed(sender, swapAmount);\n            }\n        }\n    }\n\n    event BackrunTriggered(address indexed user, uint256 profit, address token);\n    event BackrunFailed(address indexed user, uint256 swapAmount);\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"uniswapv3-style-plugin",children:"UniswapV3-Style Plugin"}),"\n",(0,i.jsx)(e.p,{children:"For concentrated liquidity pools:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract UniV3Plugin is ReflexAfterSwap {\n    struct BackrunConfig {\n        uint256 minThreshold;\n        uint256 maxBackrunRatio;    // Max % of swap to use for backrun\n        bool enabledForUsers;\n        mapping(address => bool) excludedUsers;\n    }\n\n    BackrunConfig public config;\n\n    constructor(\n        address _reflexRouter,\n        address _pool\n    ) ReflexAfterSwap(_reflexRouter, _pool) {\n        config.minThreshold = 1e18;\n        config.maxBackrunRatio = 500; // 5% in basis points\n        config.enabledForUsers = true;\n    }\n\n    function afterSwap(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override onlyPool {\n        if (!config.enabledForUsers || config.excludedUsers[sender]) {\n            return; // Skip backrun for excluded users\n        }\n\n        uint256 swapAmount = amount0 > 0 ? amount0 : amount1;\n\n        if (swapAmount >= config.minThreshold) {\n            uint256 backrunAmount = (swapAmount * config.maxBackrunRatio) / 10000;\n\n            reflexRouter.triggerBackrun(\n                bytes32(uint256(uint160(pool))),\n                uint112(backrunAmount),\n                amount0 > 0,\n                sender,\n                bytes32(0) // Use default config\n            );\n        }\n    }\n\n    // Admin functions\n    function updateConfig(\n        uint256 _minThreshold,\n        uint256 _maxBackrunRatio,\n        bool _enabledForUsers\n    ) external onlyOwner {\n        config.minThreshold = _minThreshold;\n        config.maxBackrunRatio = _maxBackrunRatio;\n        config.enabledForUsers = _enabledForUsers;\n    }\n\n    function excludeUser(address user, bool excluded) external onlyOwner {\n        config.excludedUsers[user] = excluded;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"step-2-deploy-your-plugin",children:"Step 2: Deploy Your Plugin"}),"\n",(0,i.jsx)(e.p,{children:"Create a deployment script:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// scripts/deploy-plugin.ts\nimport { ethers } from "hardhat";\n\nasync function main() {\n  const [deployer] = await ethers.getSigners();\n\n  console.log("Deploying plugin with account:", deployer.address);\n\n  const Plugin = await ethers.getContractFactory("UniV2Plugin");\n  const plugin = await Plugin.deploy(\n    "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3", // Reflex Router\n    "0xYourPoolAddress", // Your pool\n    ethers.id("YOUR_PROTOCOL_CONFIG") // Config ID\n  );\n\n  await plugin.waitForDeployment();\n\n  console.log("Plugin deployed to:", await plugin.getAddress());\n\n  // Verify on Etherscan (optional)\n  if (network.name !== "hardhat") {\n    console.log("Waiting for verification...");\n    await new Promise((resolve) => setTimeout(resolve, 60000)); // Wait 1 minute\n\n    try {\n      await hre.run("verify:verify", {\n        address: await plugin.getAddress(),\n        constructorArguments: [\n          "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3",\n          "0xYourPoolAddress",\n          ethers.id("YOUR_PROTOCOL_CONFIG"),\n        ],\n      });\n    } catch (error) {\n      console.log("Verification failed:", error);\n    }\n  }\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n'})}),"\n",(0,i.jsx)(e.h3,{id:"step-3-configure-revenue-sharing",children:"Step 3: Configure Revenue Sharing"}),"\n",(0,i.jsx)(e.p,{children:"Set up profit distribution for your protocol:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// scripts/configure-revenue.ts\nimport { ethers } from "hardhat";\n\nasync function configureRevenue() {\n  const [admin] = await ethers.getSigners();\n\n  const reflexRouter = await ethers.getContractAt(\n    "ReflexRouter",\n    "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3"\n  );\n\n  const configId = ethers.id("YOUR_PROTOCOL_CONFIG");\n\n  // Configure profit split\n  const recipients = [\n    "0xYourProtocolTreasury", // Protocol treasury: 40%\n    "0xYourLPIncentives", // LP incentives: 30%\n    "0xYourDevFund", // Development fund: 20%\n    "0xYourCommunity", // Community rewards: 10%\n  ];\n\n  const shares = [40, 30, 20, 10]; // Must sum to 100\n\n  console.log("Configuring revenue sharing...");\n\n  const tx = await reflexRouter.configureRevenue(configId, recipients, shares);\n\n  await tx.wait();\n\n  console.log("Revenue configuration set!");\n  console.log("Config ID:", configId);\n  console.log("Transaction:", tx.hash);\n\n  // Verify the configuration\n  const config = await reflexRouter.getRevenueConfig(configId);\n  console.log("Stored config:", config);\n}\n\nconfigureRevenue().catch(console.error);\n'})}),"\n",(0,i.jsx)(e.h3,{id:"step-4-integrate-the-plugin",children:"Step 4: Integrate the Plugin"}),"\n",(0,i.jsx)(e.h4,{id:"option-a-modify-existing-pool-contract",children:"Option A: Modify Existing Pool Contract"}),"\n",(0,i.jsx)(e.p,{children:"If you control the pool contract, add the plugin call:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"contract YourPool {\n    address public reflexPlugin;\n\n    function setReflexPlugin(address _plugin) external onlyOwner {\n        reflexPlugin = _plugin;\n    }\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external {\n        // ... existing swap logic ...\n\n        // Trigger MEV capture after swap\n        if (reflexPlugin != address(0)) {\n            try IReflexAfterSwap(reflexPlugin).afterSwap(\n                msg.sender,\n                amount0Out,\n                amount1Out,\n                data\n            ) {} catch {\n                // Ignore plugin failures\n            }\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"option-b-use-factory-pattern",children:"Option B: Use Factory Pattern"}),"\n",(0,i.jsx)(e.p,{children:"For protocols with factory contracts:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'contract YourPoolFactory {\n    address public immutable reflexRouter;\n    mapping(address => address) public poolPlugins;\n\n    constructor(address _reflexRouter) {\n        reflexRouter = _reflexRouter;\n    }\n\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool) {\n        // Create pool logic...\n        pool = deploy2(...);\n\n        // Deploy and configure Reflex plugin\n        address plugin = new UniV2Plugin(\n            reflexRouter,\n            pool,\n            keccak256(abi.encodePacked("POOL_", pool))\n        );\n\n        poolPlugins[pool] = plugin;\n\n        // Set plugin in pool\n        IYourPool(pool).setReflexPlugin(plugin);\n\n        emit PoolCreated(pool, plugin);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"-sdk-integration-guide",children:"\ud83d\udcf1 SDK Integration Guide"}),"\n",(0,i.jsx)(e.h3,{id:"step-1-install-and-initialize",children:"Step 1: Install and Initialize"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"npm install @reflex/sdk ethers\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'import { ReflexSDK } from "@reflex/sdk";\nimport { ethers } from "ethers";\n\nconst provider = new ethers.JsonRpcProvider(RPC_URL);\nconst signer = new ethers.Wallet(PRIVATE_KEY, provider);\n\nconst reflex = new ReflexSDK(\n  provider,\n  REFLEX_ROUTER_ADDRESS,\n  REFLEX_QUOTER_ADDRESS\n);\n'})}),"\n",(0,i.jsx)(e.h3,{id:"step-2-monitor-and-execute",children:"Step 2: Monitor and Execute"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// Monitor for opportunities\nasync function monitorAndExecute() {\n  // Listen for swap events from target pools\n  const pools = ["0xPool1", "0xPool2", "0xPool3"];\n\n  for (const poolAddress of pools) {\n    const poolContract = new ethers.Contract(poolAddress, POOL_ABI, provider);\n\n    poolContract.on(\n      "Swap",\n      async (sender, amount0In, amount1In, amount0Out, amount1Out) => {\n        const swapAmount = amount0In > 0 ? amount0In : amount1In;\n\n        // Check if opportunity is profitable\n        const params = {\n          triggerPoolId: poolAddress,\n          swapAmountIn: swapAmount / 10n, // Use 10% for backrun\n          token0In: amount0In > 0,\n          recipient: sender, // Share profit with original swapper\n          configId: ethers.ZeroHash, // Use default config\n        };\n\n        try {\n          const gasEstimate = await reflex.estimateBackrunGas(params);\n\n          if (gasEstimate > 0) {\n            console.log("Executing backrun for pool:", poolAddress);\n\n            const result = await reflex.triggerBackrun(signer, params, {\n              gasLimit: gasEstimate + 50000n,\n            });\n\n            console.log("Backrun profit:", ethers.formatEther(result.profit));\n          }\n        } catch (error) {\n          console.error("Backrun failed:", error);\n        }\n      }\n    );\n  }\n}\n\nmonitorAndExecute();\n'})}),"\n",(0,i.jsx)(e.h3,{id:"step-3-advanced-strategies",children:"Step 3: Advanced Strategies"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// Batch multiple backruns\nasync function batchBackruns(opportunities: BackrunOpportunity[]) {\n  const executeParams = {\n    target: "0x0000000000000000000000000000000000000000", // No initial call\n    value: 0n,\n    callData: "0x",\n  };\n\n  const backrunParams = opportunities.map((opp) => ({\n    triggerPoolId: opp.poolId,\n    swapAmountIn: opp.amount,\n    token0In: opp.token0In,\n    recipient: opp.recipient,\n    configId: opp.configId || ethers.ZeroHash,\n  }));\n\n  const result = await reflex.backrunedExecute(\n    signer,\n    executeParams,\n    backrunParams\n  );\n\n  console.log("Batch results:", result.profits);\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"-testing-your-integration",children:"\ud83d\udd27 Testing Your Integration"}),"\n",(0,i.jsx)(e.h3,{id:"unit-tests",children:"Unit Tests"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'import { expect } from "chai";\nimport { ethers } from "hardhat";\n\ndescribe("Reflex Plugin Integration", function () {\n  let plugin, reflexRouter, pool, owner, user;\n\n  beforeEach(async function () {\n    [owner, user] = await ethers.getSigners();\n\n    // Deploy mock contracts\n    const MockRouter = await ethers.getContractFactory("MockReflexRouter");\n    reflexRouter = await MockRouter.deploy();\n\n    const MockPool = await ethers.getContractFactory("MockPool");\n    pool = await MockPool.deploy();\n\n    // Deploy plugin\n    const Plugin = await ethers.getContractFactory("UniV2Plugin");\n    plugin = await Plugin.deploy(\n      await reflexRouter.getAddress(),\n      await pool.getAddress(),\n      ethers.id("TEST_CONFIG")\n    );\n  });\n\n  it("should trigger backrun on large swaps", async function () {\n    const swapAmount = ethers.parseEther("10"); // Large swap\n\n    await expect(plugin.afterSwap(user.address, swapAmount, 0, "0x")).to.emit(\n      plugin,\n      "BackrunTriggered"\n    );\n  });\n\n  it("should not trigger backrun on small swaps", async function () {\n    const swapAmount = ethers.parseEther("0.1"); // Small swap\n\n    await expect(\n      plugin.afterSwap(user.address, swapAmount, 0, "0x")\n    ).to.not.emit(plugin, "BackrunTriggered");\n  });\n});\n'})}),"\n",(0,i.jsx)(e.h3,{id:"integration-tests",children:"Integration Tests"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'describe("End-to-End Integration", function () {\n  it("should capture MEV and distribute profits", async function () {\n    // 1. User performs swap\n    await pool\n      .connect(user)\n      .swap(ethers.parseEther("1"), 0, user.address, "0x");\n\n    // 2. Plugin should trigger backrun\n    // 3. Profits should be distributed\n    // 4. User should receive their share\n\n    const userBalance = await token.balanceOf(user.address);\n    expect(userBalance).to.be.gt(initialBalance);\n  });\n});\n'})}),"\n",(0,i.jsx)(e.h2,{id:"-monitoring-and-analytics",children:"\ud83d\udcca Monitoring and Analytics"}),"\n",(0,i.jsx)(e.h3,{id:"event-monitoring",children:"Event Monitoring"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// Monitor all Reflex events\nreflex.onBackrunExecuted((event) => {\n  console.log("Backrun executed:", {\n    pool: event.triggerPoolId,\n    profit: ethers.formatEther(event.profit),\n    user: event.recipient,\n    token: event.profitToken,\n  });\n\n  // Send to analytics\n  analytics.track("MEV_Captured", {\n    pool: event.triggerPoolId,\n    profit: event.profit,\n    block: event.blockNumber,\n  });\n});\n\nreflex.onRevenueDistributed((event) => {\n  console.log("Revenue distributed:", {\n    config: event.configId,\n    token: event.token,\n    total: ethers.formatEther(event.totalAmount),\n  });\n});\n'})}),"\n",(0,i.jsx)(e.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:"class ReflexMetrics {\n  private totalMEVCaptured = 0n;\n  private totalBackruns = 0;\n  private successRate = 0;\n\n  trackBackrun(profit: bigint, success: boolean) {\n    if (success) {\n      this.totalMEVCaptured += profit;\n    }\n    this.totalBackruns++;\n    this.successRate =\n      this.totalBackruns > 0\n        ? (this.successfulBackruns / this.totalBackruns) * 100\n        : 0;\n  }\n\n  getMetrics() {\n    return {\n      totalMEVCaptured: this.totalMEVCaptured,\n      totalBackruns: this.totalBackruns,\n      successRate: this.successRate,\n      averageProfit:\n        this.totalBackruns > 0\n          ? this.totalMEVCaptured / BigInt(this.totalBackruns)\n          : 0n,\n    };\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"-deployment-checklist",children:"\ud83d\ude80 Deployment Checklist"}),"\n",(0,i.jsx)(e.p,{children:"Before deploying to mainnet:"}),"\n",(0,i.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Security Audit"}),": Have your integration audited"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Gas Optimization"}),": Test gas usage under various conditions"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Fallback Handling"}),": Ensure MEV failures don't break core functionality"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Configuration"}),": Set up proper revenue sharing configurations"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Monitoring"}),": Deploy monitoring and alerting systems"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Documentation"}),": Document your integration for users"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Testing"}),": Comprehensive testing on testnets"]}),"\n",(0,i.jsxs)(e.li,{className:"task-list-item",children:[(0,i.jsx)(e.input,{type:"checkbox",disabled:!0})," ",(0,i.jsx)(e.strong,{children:"Emergency Procedures"}),": Plan for emergency stops/updates"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"-common-issues-and-solutions",children:"\ud83c\udd98 Common Issues and Solutions"}),"\n",(0,i.jsx)(e.h3,{id:"issue-plugin-not-triggering",children:"Issue: Plugin Not Triggering"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Symptoms:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["No ",(0,i.jsx)(e.code,{children:"BackrunTriggered"})," events"]}),"\n",(0,i.jsx)(e.li,{children:"Plugin function not being called"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Solutions:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Check pool integration is correct"}),"\n",(0,i.jsx)(e.li,{children:"Verify plugin address is set in pool"}),"\n",(0,i.jsx)(e.li,{children:"Ensure minimum thresholds are met"}),"\n",(0,i.jsx)(e.li,{children:"Check gas limits"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-backruns-always-failing",children:"Issue: Backruns Always Failing"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Symptoms:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"BackrunFailed"})," events"]}),"\n",(0,i.jsx)(e.li,{children:"Transactions reverting"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Solutions:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Check pool liquidity is sufficient"}),"\n",(0,i.jsx)(e.li,{children:"Verify Reflex Router address is correct"}),"\n",(0,i.jsx)(e.li,{children:"Ensure proper token approvals"}),"\n",(0,i.jsx)(e.li,{children:"Check slippage parameters"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"issue-no-profits-being-distributed",children:"Issue: No Profits Being Distributed"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Symptoms:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Backruns succeed but no profit distribution"}),"\n",(0,i.jsx)(e.li,{children:"Revenue events not emitted"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Solutions:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Verify revenue configuration is set"}),"\n",(0,i.jsx)(e.li,{children:"Check configuration ID matches"}),"\n",(0,i.jsx)(e.li,{children:"Ensure recipients are valid addresses"}),"\n",(0,i.jsx)(e.li,{children:"Check for sufficient profit amounts"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:["For more advanced integration patterns and examples, see our ",(0,i.jsx)(e.a,{href:"../examples/basic-backrun",children:"Examples"})," section and ",(0,i.jsx)(e.a,{href:"../api/smart-contracts",children:"API Reference"}),"."]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}}}]);