"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[5585],{6625:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var t=r(4848),a=r(8453);const i={sidebar_position:3},s="Universal DEX Integration",o={id:"integration/universal-dex",title:"Universal DEX Integration",description:"Integrate Reflex MEV capture into any DEX and client applications using the TypeScript SDK and BackrunEnabledSwapProxy contract.",source:"@site/docs/integration/universal-dex.md",sourceDirName:"integration",slug:"/integration/universal-dex",permalink:"/reflex/integration/universal-dex",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/integration/universal-dex.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Plugin-Based Integration",permalink:"/reflex/integration/plugin-based"},next:{title:"Direct Contract Access",permalink:"/reflex/integration/direct-access"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Components",id:"components",level:2},{value:"1. BackrunEnabledSwapProxy Contract",id:"1-backrunenabledswapproxy-contract",level:3},{value:"2. Reflex SDK with UniversalIntegration",id:"2-reflex-sdk-with-universalintegration",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Step 1: Deploy SwapProxy (One-time Setup)",id:"step-1-deploy-swapproxy-one-time-setup",level:3},{value:"Step 2: Install SDK",id:"step-2-install-sdk",level:3},{value:"Step 3: Initialize UniversalIntegration",id:"step-3-initialize-universalintegration",level:3},{value:"Using the Universal Integration API",id:"using-the-universal-integration-api",level:2},{value:"Basic Swap with MEV Capture",id:"basic-swap-with-mev-capture",level:3},{value:"SwapProxy Deployment Guide",id:"swapproxy-deployment-guide",level:2},{value:"Deploying for Your DEX",id:"deploying-for-your-dex",level:3},{value:"Configuration and Optimization",id:"configuration-and-optimization",level:2},{value:"Gas Management",id:"gas-management",level:3},{value:"Event Monitoring",id:"event-monitoring",level:3}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"universal-dex-integration",children:"Universal DEX Integration"})}),"\n",(0,t.jsxs)(n.p,{children:["Integrate Reflex MEV capture into any DEX and client applications using the TypeScript SDK and ",(0,t.jsx)(n.code,{children:"BackrunEnabledSwapProxy"})," contract."]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Universal DEX integration method enables MEV capture for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Legacy DEXes"})," that don't support hooks/plugins"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frontend applications"})," and DApp interfaces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Any DEX router"})," without requiring code changes"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach uses a proxy contract to wrap existing DEX routers, combined with a TypeScript SDK for easy client-side integration."}),"\n",(0,t.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant DApp/SDK\n    participant SwapProxy\n    participant DEX Router\n    participant Reflex Router\n\n    User->>DApp/SDK: Initiate Swap\n    DApp/SDK->>SwapProxy: swapWithBackrun()\n    SwapProxy->>SwapProxy: Transfer tokens from user\n    SwapProxy->>DEX Router: Execute swap\n    DEX Router--\x3e>SwapProxy: Swap complete\n    SwapProxy->>SwapProxy: Return leftover tokens\n    SwapProxy->>Reflex Router: Trigger backrun(s)\n    Reflex Router--\x3e>SwapProxy: MEV profits\n    SwapProxy--\x3e>User: Return profits + tokens\n    DApp/SDK--\x3e>User: Display results"}),"\n",(0,t.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,t.jsx)(n.h3,{id:"1-backrunenabledswapproxy-contract",children:"1. BackrunEnabledSwapProxy Contract"}),"\n",(0,t.jsx)(n.p,{children:"A smart contract that wraps any existing DEX router and adds MEV capture functionality."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Works with any DEX router (Uniswap, SushiSwap, PancakeSwap, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"Atomic swap + backrun execution"}),"\n",(0,t.jsx)(n.li,{children:"Automatic token approval management"}),"\n",(0,t.jsx)(n.li,{children:"Returns leftover tokens and ETH to users"}),"\n",(0,t.jsx)(n.li,{children:"Reentrancy protected"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deployment:"}),"\nOne proxy contract per target DEX router you want to support."]}),"\n",(0,t.jsx)(n.h3,{id:"2-reflex-sdk-with-universalintegration",children:"2. Reflex SDK with UniversalIntegration"}),"\n",(0,t.jsx)(n.p,{children:"A client-side library that simplifies interaction with the SwapProxy and Reflex contracts."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Type-safe interfaces matching contract exactly"}),"\n",(0,t.jsx)(n.li,{children:"Automatic token approval helpers"}),"\n",(0,t.jsx)(n.li,{children:"Gas estimation"}),"\n",(0,t.jsx)(n.li,{children:"Multi-chain support"}),"\n",(0,t.jsx)(n.li,{children:"Built on ethers.js v6"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,t.jsx)(n.h3,{id:"step-1-deploy-swapproxy-one-time-setup",children:"Step 1: Deploy SwapProxy (One-time Setup)"}),"\n",(0,t.jsxs)(n.p,{children:["Deploy a ",(0,t.jsx)(n.code,{children:"BackrunEnabledSwapProxy"})," contract for your target DEX router:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:'// Deploy via Foundry script or directly\nimport {BackrunEnabledSwapProxy} from "@reflex/contracts/integrations/router/BackrunEnabledSwapProxy.sol";\n\n// Constructor takes the target DEX router address\nBackrunEnabledSwapProxy proxy = new BackrunEnabledSwapProxy(\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D  // Uniswap V2 Router\n);\n'})}),"\n",(0,t.jsx)(n.p,{children:"Or use the provided deployment script:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Set environment variables\nexport TARGET_ROUTER_ADDRESS=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n\n# Deploy\nforge script script/deploy-swap-proxy/DeployBackrunEnabledSwapProxy.s.sol \\\n    --rpc-url <YOUR_RPC_URL> \\\n    --private-key <YOUR_PRIVATE_KEY> \\\n    --broadcast\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-install-sdk",children:"Step 2: Install SDK"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install @reflex-mev/sdk ethers\n# or\nyarn add @reflex-mev/sdk ethers\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-3-initialize-universalintegration",children:"Step 3: Initialize UniversalIntegration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\nimport { ethers } from "ethers";\n\n// Initialize provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  "https://mainnet.infura.io/v3/YOUR_KEY"\n);\nconst signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);\n\n// Create UniversalIntegration instance\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  "0xYourSwapProxyAddress", // SwapProxy contract address\n  "0xYourReflexRouterAddress" // Reflex Router address\n);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"using-the-universal-integration-api",children:"Using the Universal Integration API"}),"\n",(0,t.jsx)(n.h3,{id:"basic-swap-with-mev-capture",children:"Basic Swap with MEV Capture"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\nimport { ethers } from "ethers";\n\n// Initialize integration\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  swapProxyAddress,\n  reflexRouterAddress\n);\n\n// Encode swap calldata for target DEX router\n// Example: Uniswap V2 swapExactTokensForTokens\nconst targetDexInterface = new ethers.Interface([\n  "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] path, address to, uint deadline)",\n]);\n\nconst swapCalldata = targetDexInterface.encodeFunctionData(\n  "swapExactTokensForTokens",\n  [\n    ethers.parseEther("1.0"), // amountIn\n    ethers.parseEther("0.95"), // amountOutMin (with slippage)\n    [tokenInAddress, tokenOutAddress], // path\n    userAddress, // to\n    Math.floor(Date.now() / 1000) + 60 * 20, // deadline (20 min)\n  ]\n);\n\n// Prepare swap metadata\nconst swapMetadata = {\n  swapTxCallData: swapCalldata,\n  tokenIn: tokenInAddress,\n  amountIn: ethers.parseEther("1.0"),\n  tokenOut: tokenOutAddress,\n  recipient: userAddress,\n};\n\n// Prepare backrun parameters\nconst backrunParams = [\n  {\n    triggerPoolId: poolAddress, // Pool being traded on\n    swapAmountIn: ethers.parseEther("1.0"), // Full swap amount\n    token0In: true, // Swap direction\n    recipient: userAddress,\n    configId: ethers.ZeroHash, // Use default config\n  },\n];\n\n// Approve tokens to SwapProxy first\nawait integration.approveTokens([\n  {\n    tokenAddress: tokenInAddress,\n    amount: ethers.parseEther("1.0"),\n  },\n]);\n\n// Execute swap with automatic MEV capture\nconst result = await integration.swapWithBackrun(\n  swapMetadata,\n  backrunParams,\n  { gasLimit: 1500000n } // Optional: ethers Overrides\n);\n\nconsole.log("Transaction:", result.transactionHash);\nconsole.log("Gas used:", result.gasUsed.toString());\nconsole.log("Profits:", result.profits);\nconsole.log("Profit tokens:", result.profitTokens);\n'})}),"\n",(0,t.jsx)(n.h2,{id:"swapproxy-deployment-guide",children:"SwapProxy Deployment Guide"}),"\n",(0,t.jsx)(n.h3,{id:"deploying-for-your-dex",children:"Deploying for Your DEX"}),"\n",(0,t.jsx)(n.p,{children:"Deploy a SwapProxy for each DEX router you want to support:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Clone the Reflex repository\ngit clone --recursive https://github.com/reflex-mev/reflex.git\ncd reflex/core\n\n# Set environment variables\nexport TARGET_ROUTER_ADDRESS=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D  # Uniswap V2 Router\n\n# Deploy using Forge\nforge script script/deploy-swap-proxy/DeployBackrunEnabledSwapProxy.s.sol \\\n    --rpc-url $RPC_URL \\\n    --private-key $PRIVATE_KEY \\\n    --broadcast \\\n    --verify\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-and-optimization",children:"Configuration and Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"gas-management",children:"Gas Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Use ethers Overrides for transaction options\nconst result = await integration.swapWithBackrun(swapMetadata, backrunParams, {\n  gasLimit: 1500000n, // Recommended for MEV operations\n  maxFeePerGas: ethers.parseUnits("100", "gwei"),\n  maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"),\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"event-monitoring",children:"Event Monitoring"}),"\n",(0,t.jsx)(n.p,{children:"Monitor MEV capture events from the Reflex Router:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Event monitoring through provider\nimport { Interface } from "ethers";\nimport { REFLEX_ROUTER_ABI } from "@reflex-mev/sdk";\n\nconst routerInterface = new Interface(REFLEX_ROUTER_ABI);\n\n// Listen for BackrunExecuted events\nprovider.on(\n  {\n    address: reflexRouterAddress,\n    topics: [routerInterface.getEvent("BackrunExecuted").topicHash],\n  },\n  (log) => {\n    const event = routerInterface.parseLog(log);\n\n    console.log("MEV Captured!", {\n      profit: ethers.formatEther(event.args.profit),\n      profitToken: event.args.profitToken,\n      triggerPoolId: event.args.triggerPoolId,\n      recipient: event.args.recipient,\n    });\n\n    // Update UI or analytics\n    analytics.track("MEV_Captured", {\n      profit: event.args.profit,\n      timestamp: Date.now(),\n    });\n  }\n);\n'})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}}}]);