"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[361],{8321:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var n=r(4848),i=r(8453);const s={sidebar_position:0,slug:"/"},o="Overview",l={id:"index",title:"Overview",description:"Introduction",source:"@site/docs/index.md",sourceDirName:".",slug:"/",permalink:"/reflex/",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/index.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,slug:"/"},sidebar:"tutorialSidebar",next:{title:"Architecture",permalink:"/reflex/architecture"}},a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Key features:",id:"key-features",level:3},{value:"Protocol Integrations",id:"protocol-integrations",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Reflex vs External Arbitrage",id:"reflex-vs-external-arbitrage",level:3},{value:"Why this matters:",id:"why-this-matters",level:3},{value:"Integration Types",id:"integration-types",level:3},{value:"1. Protocol Hooks",id:"1-protocol-hooks",level:4},{value:"2. Router Integration",id:"2-router-integration",level:4},{value:"3. EIP-7702 (Account Abstraction Bundles)",id:"3-eip-7702-account-abstraction-bundles",level:4},{value:"4. SDK Integration",id:"4-sdk-integration",level:4},{value:"Supported Protocols",id:"supported-protocols",level:3},{value:"Getting Started",id:"getting-started",level:3},{value:"Technical Documentation",id:"technical-documentation",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"overview",children:"Overview"})}),"\n",(0,n.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsx)(t.p,{children:"Reflex is an on-chain MEV capture engine designed to reclaim backrun profits for protocols, users, and ecosystems. Instead of letting external actors extract value, Reflex routes that value back into the protocol environment."}),"\n",(0,n.jsx)(t.h3,{id:"key-features",children:"Key features:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"100% on-chain"}),": no backend dependencies, no private servers."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Plug and play"}),": integration requires no changes to existing smart contracts."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Secure by design"}),": Reflex is fully non-custodial, operating independently of user funds and requiring no approval access."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Cross-ecosystem"}),": works across EVM protocols, and L1,L2 environments."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"protocol-integrations",children:"Protocol Integrations"}),"\n",(0,n.jsx)(t.h3,{id:"overview-1",children:"Overview"}),"\n",(0,n.jsx)(t.p,{children:"Protocols can integrate Reflex at different levels of depth. From pool-level hooks to router-level integration, Reflex adapts to the architecture you already use."}),"\n",(0,n.jsx)(t.h3,{id:"reflex-vs-external-arbitrage",children:"Reflex vs External Arbitrage"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{}),(0,n.jsx)(t.th,{children:"External Arbitrage (current state)"}),(0,n.jsx)(t.th,{children:"Reflex (integrated)"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"MEV profits"})}),(0,n.jsx)(t.td,{children:"Captured by third-party searchers, exit the ecosystem"}),(0,n.jsx)(t.td,{children:"Redirected on-chain to users or the protocol treasury"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Protocol revenue"})}),(0,n.jsx)(t.td,{children:"None \u2014 profits leak to external actors"}),(0,n.jsx)(t.td,{children:"Configurable share of profits accrue to the protocol"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Execution control"})}),(0,n.jsx)(t.td,{children:"Uncoordinated, opaque, dependent on external bots"}),(0,n.jsx)(t.td,{children:"Native, deterministic, fully on-chain"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.strong,{children:"Security"})}),(0,n.jsx)(t.td,{children:"No alignment between arbitrageur and protocol"}),(0,n.jsx)(t.td,{children:"Protocol retains control of how profits are distributed"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"why-this-matters",children:"Why this matters:"}),"\n",(0,n.jsx)(t.p,{children:"Arbitrage is inevitable, but today it benefits external actors who have no alignment with your protocol. Reflex ensures the same arbitrage happens within your ecosystem and its profits are redistributed according to your rules."}),"\n",(0,n.jsx)(t.h3,{id:"integration-types",children:"Integration Types"}),"\n",(0,n.jsx)(t.h4,{id:"1-protocol-hooks",children:"1. Protocol Hooks"}),"\n",(0,n.jsx)(t.p,{children:"Reflex integrates natively with modern hook/plugin architectures:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"PancakeSwap Infinity hooks"}),"\n",(0,n.jsx)(t.li,{children:"Algebra Integral plugins"}),"\n",(0,n.jsx)(t.li,{children:"Uniswap v4 hooks"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"How it works:"})})}),"\n",(0,n.jsxs)(t.p,{children:["When a user executes a swap, Reflex's integrated ",(0,n.jsx)(t.code,{children:"afterSwap"})," is triggered to capture arbitrage opportunities across pools and protocols, with profits routed back to the protocol treasury or designated addresses."]}),"\n",(0,n.jsx)(t.h4,{id:"2-router-integration",children:"2. Router Integration"}),"\n",(0,n.jsx)(t.p,{children:"For DEXs that don't use a hook system, Reflex can integrate directly into the router contract. This method enables the router to trigger Reflex opportunities whenever trades pass through it."}),"\n",(0,n.jsx)(t.h4,{id:"3-eip-7702-account-abstraction-bundles",children:"3. EIP-7702 (Account Abstraction Bundles)"}),"\n",(0,n.jsx)(t.p,{children:"Reflex supports account abstraction environments where trades can be wrapped into bundles. This allows traders and protocols to:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Embed Reflex backruns into user-submitted bundles."}),"\n",(0,n.jsx)(t.li,{children:"Ensure arbitrage profits are redirected back on-chain."}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"4-sdk-integration",children:"4. SDK Integration"}),"\n",(0,n.jsx)(t.p,{children:"Use the TypeScript SDK for custom MEV strategies and manual triggers. This approach gives you full control over when and how backruns are executed, perfect for building sophisticated MEV bots, custom trading strategies, or integrating Reflex into existing applications with specific requirements."}),"\n",(0,n.jsx)(t.h3,{id:"supported-protocols",children:"Supported Protocols"}),"\n",(0,n.jsx)(t.p,{children:"Reflex is protocol-agnostic and already runs with leading DEXs and aggregators across EVM ecosystem."}),"\n",(0,n.jsx)(t.h3,{id:"getting-started",children:"Getting Started"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Contact us to request an API key."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Configure payout addresses."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Plug and play integration (hook, router, sdk)."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Start capturing MEV profits immediately."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"technical-documentation",children:"Technical Documentation"}),"\n",(0,n.jsx)(t.p,{children:"Ready to integrate Reflex into your protocol? Check out our comprehensive guides:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\ufffd ",(0,n.jsx)(t.a,{href:"./integration/overview",children:(0,n.jsx)(t.strong,{children:"Integration Guide"})})," - Step-by-step integration instructions"]}),"\n",(0,n.jsxs)(t.li,{children:["\ufffd ",(0,n.jsx)(t.a,{href:"./api/smart-contracts",children:(0,n.jsx)(t.strong,{children:"API Reference"})})," - Complete contract documentation"]}),"\n",(0,n.jsxs)(t.li,{children:["\ud83c\udfd7\ufe0f ",(0,n.jsx)(t.a,{href:"./architecture",children:(0,n.jsx)(t.strong,{children:"Architecture"})})," - Understand the system design"]}),"\n",(0,n.jsxs)(t.li,{children:["\ufffd ",(0,n.jsx)(t.a,{href:"./security",children:(0,n.jsx)(t.strong,{children:"Security"})})," - Security considerations and best practices"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"./integration/overview",children:"Start with Integration"})})," - Learn how to integrate Reflex"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"./architecture",children:"Read the Architecture"})})," - Understand the system design"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"./integration/smart-contract",children:"Deploy Your First Integration"})})," - Start capturing MEV"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"./integration/sdk-integration",children:"Use the SDK"})})," - Build with the TypeScript SDK"]}),"\n"]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Ready to revolutionize MEV capture? Let's get started! \ud83d\ude80"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}}}]);