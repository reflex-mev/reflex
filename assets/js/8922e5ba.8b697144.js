"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[5939],{8465:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var a=r(4848),s=r(8453);const t={sidebar_position:3},i="BackrunEnabledSwapProxy",o={id:"api/backrun-enabled-swap-proxy",title:"BackrunEnabledSwapProxy",description:"Proxy contract that wraps any DEX router to add MEV capture functionality through the UniversalIntegration pattern.",source:"@site/docs/api/backrun-enabled-swap-proxy.md",sourceDirName:"api",slug:"/api/backrun-enabled-swap-proxy",permalink:"/api/backrun-enabled-swap-proxy",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/api/backrun-enabled-swap-proxy.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"ReflexAfterSwap",permalink:"/api/reflex-after-swap"},next:{title:"UniversalIntegration",permalink:"/api/sdk/universal-integration"}},d={},l=[{value:"Constructor",id:"constructor",level:2},{value:"State Variables",id:"state-variables",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"swapWithBackrun",id:"swapwithbackrun",level:3},{value:"Deployment",id:"deployment",level:2},{value:"Usage with SDK",id:"usage-with-sdk",level:2},{value:"Error Messages",id:"error-messages",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"backrunenabledswapproxy",children:"BackrunEnabledSwapProxy"})}),"\n",(0,a.jsx)(n.p,{children:"Proxy contract that wraps any DEX router to add MEV capture functionality through the UniversalIntegration pattern."}),"\n",(0,a.jsx)(n.h2,{id:"constructor",children:"Constructor"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"constructor(address _targetRouter)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"_targetRouter"})," - Address of the target DEX router to wrap (e.g., Uniswap V2 Router, SushiSwap Router)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Validation:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Target router address must be non-zero"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"state-variables",children:"State Variables"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"address public immutable targetRouter;  // The wrapped DEX router address\n"})}),"\n",(0,a.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,a.jsx)(n.h3,{id:"swapwithbackrun",children:"swapWithBackrun"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"function swapWithBackrun(\n    SwapMetadata calldata swapMetadata,\n    address reflexRouter,\n    BackrunParams[] calldata backrunParams\n) external payable returns (\n    bytes memory swapReturnData,\n    uint256[] memory profits,\n    address[] memory profitTokens\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"Executes a swap through the target DEX router and triggers MEV backrun(s)."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"struct SwapMetadata {\n    bytes swapTxCallData;  // Encoded calldata for the target router\n    address tokenIn;       // Input token address\n    uint256 amountIn;      // Input token amount\n    address tokenOut;      // Output token address\n    address recipient;     // Recipient of swap output and profits\n}\n\nstruct BackrunParams {\n    bytes32 triggerPoolId;  // Pool identifier\n    uint112 swapAmountIn;   // Full swap amount\n    bool token0In;          // Swap direction\n    address recipient;      // Profit recipient\n    bytes32 configId;       // Configuration ID\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"swapReturnData"})," - Return data from the DEX router swap call"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"profits"})," - Array of profit amounts from each backrun"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"profitTokens"})," - Array of profit token addresses"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Process:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Transfers ",(0,a.jsx)(n.code,{children:"tokenIn"})," from caller to proxy"]}),"\n",(0,a.jsxs)(n.li,{children:["Approves ",(0,a.jsx)(n.code,{children:"tokenIn"})," to target router"]}),"\n",(0,a.jsxs)(n.li,{children:["Executes swap via target router using ",(0,a.jsx)(n.code,{children:"swapTxCallData"})]}),"\n",(0,a.jsx)(n.li,{children:"Triggers backrun(s) via ReflexRouter"}),"\n",(0,a.jsx)(n.li,{children:"Returns leftover tokens and ETH to recipient"}),"\n",(0,a.jsx)(n.li,{children:"Returns profits to recipient"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example:"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'// Encode swap for Uniswap V2\nbytes memory swapCalldata = abi.encodeWithSignature(\n    "swapExactTokensForTokens(uint256,uint256,address[],address,uint256)",\n    amountIn,\n    amountOutMin,\n    path,\n    recipient,\n    deadline\n);\n\n// Prepare metadata\nSwapMetadata memory metadata = SwapMetadata({\n    swapTxCallData: swapCalldata,\n    tokenIn: USDC,\n    amountIn: 1000e6,\n    tokenOut: WETH,\n    recipient: msg.sender\n});\n\n// Prepare backrun params\nBackrunParams[] memory backrunParams = new BackrunParams[](1);\nbackrunParams[0] = BackrunParams({\n    triggerPoolId: bytes32(uint256(uint160(poolAddress))),\n    swapAmountIn: 1000e6,\n    token0In: true,\n    recipient: msg.sender,\n    configId: bytes32(0)\n});\n\n// Execute\n(bytes memory returnData, uint256[] memory profits, address[] memory profitTokens) =\n    swapProxy.swapWithBackrun(metadata, reflexRouterAddress, backrunParams);\n'})}),"\n",(0,a.jsx)(n.h2,{id:"deployment",children:"Deployment"}),"\n",(0,a.jsx)(n.p,{children:"Deploy one proxy per target DEX router:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// Deploy for Uniswap V2\nBackrunEnabledSwapProxy uniswapProxy = new BackrunEnabledSwapProxy(\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D  // Uniswap V2 Router\n);\n\n// Deploy for SushiSwap\nBackrunEnabledSwapProxy sushiProxy = new BackrunEnabledSwapProxy(\n    0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F  // SushiSwap Router\n);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Or using Foundry script:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"forge script script/deploy-swap-proxy/DeployBackrunEnabledSwapProxy.s.sol \\\n    --rpc-url $RPC_URL \\\n    --private-key $PRIVATE_KEY \\\n    --broadcast\n"})}),"\n",(0,a.jsx)(n.h2,{id:"usage-with-sdk",children:"Usage with SDK"}),"\n",(0,a.jsx)(n.p,{children:"The BackrunEnabledSwapProxy is designed to work seamlessly with the UniversalIntegration SDK:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { UniversalIntegration } from "@reflex-mev/sdk/integrations";\n\nconst integration = new UniversalIntegration(\n  provider,\n  signer,\n  swapProxyAddress, // BackrunEnabledSwapProxy address\n  reflexRouterAddress\n);\n\nawait integration.swapWithBackrun(swapMetadata, backrunParams);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"../integration/universal-dex",children:"Universal DEX Integration"})," for complete SDK documentation."]}),"\n",(0,a.jsx)(n.h2,{id:"error-messages",children:"Error Messages"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'"Invalid target router address"'})," - Target router is zero address in constructor"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'"Token transfer failed"'})," - Failed to transfer input tokens from caller"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:'"Swap execution failed"'})," - Target router call reverted"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);