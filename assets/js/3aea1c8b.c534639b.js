"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[7427],{5506:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var r=t(4848),a=t(8453);const i={sidebar_position:2},o="SDK Reference",s={id:"api/sdk-reference",title:"SDK Reference",description:"Complete reference for the Reflex TypeScript SDK, providing easy integration with Reflex smart contracts.",source:"@site/docs/api/sdk-reference.md",sourceDirName:"api",slug:"/api/sdk-reference",permalink:"/reflex/api/sdk-reference",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/api/sdk-reference.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2}},c={},d=[{value:"\ud83d\udce6 Installation",id:"-installation",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"sdk-reference",children:"SDK Reference"})}),"\n",(0,r.jsx)(e.p,{children:"Complete reference for the Reflex TypeScript SDK, providing easy integration with Reflex smart contracts."}),"\n",(0,r.jsx)(e.h2,{id:"-installation",children:"\ud83d\udce6 Installation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'npm install @reflex-mev/sdk\n# or\nyarn add Token Amount Fo### Profit Calculations\n\n\n## \ud83d\ude80 Quick Start\n\n```typescript\nimport { ReflexSDK } from "@reflex-mev/sdk";\nimport { ethers } from "ethers";\n\n// Initialize provider and signer\nconst provider = new ethers.JsonRpcProvider(\n  "https://mainnet.infura.io/v3/YOUR_KEY"\n);\nconst signer = new ethers.Wallet("YOUR_PRIVATE_KEY", provider);\n\n// Create SDK instance with router address\nconst reflex = new ReflexSDK(\n  provider,\n  signer,\n  "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3" // Reflex Router address\n);\n```\n\n## \ud83d\udd27 Configuration\n\n### Constructor\n\n```typescript\nconstructor(\n    provider: Provider,\n    signer: Signer,\n    routerAddress: string\n)\n```\n\n**Parameters:**\n\n- `provider` - Ethers provider for reading blockchain data\n- `signer` - Ethers signer for sending transactions\n- `routerAddress` - Address of the deployed Reflex Router contract\n\n## \ud83d\udccb Core Methods\n\n### `backrunedExecute()`\n\nExecutes arbitrary calldata on a target contract and then triggers multiple backruns.\n\n```typescript\nconst result = await reflex.backrunedExecute(\n  executeParams,\n  backrunParams,\n  options\n);\n```\n\n**Parameters:**\n\n```typescript\ninterface ExecuteParams {\n  target: string; // Target contract address to call\n  value: bigint; // ETH value to send with the call (in wei)\n  callData: BytesLike; // Encoded calldata to execute\n}\n\ninterface BackrunParams {\n  triggerPoolId: string; // Pool ID that triggered the opportunity (bytes32)\n  swapAmountIn: BigNumberish; // Input swap amount\n  token0In: boolean; // Whether token0 is used as input\n  recipient: string; // Address to receive profits\n  configId?: string; // Optional: Configuration ID for profit splitting (bytes32)\n}\n\ninterface TransactionOptions {\n  gasLimit?: bigint;\n  gasPrice?: bigint;\n  maxFeePerGas?: bigint;\n  maxPriorityFeePerGas?: bigint;\n  nonce?: number;\n}\n```\n\n**Returns:**\n\n```typescript\ninterface BackrunedExecuteResult {\n  success: boolean; // Whether the initial call succeeded\n  returnData: string; // Return data from the initial call\n  profits: bigint[]; // Array of profits from each backrun\n  profitTokens: string[]; // Array of profit token addresses\n  transactionHash: string; // Transaction hash\n}\n```\n\n### `estimateBackrunedExecuteGas()`\n\nEstimates gas for a backruned execute operation.\n\n```typescript\nconst gasEstimate = await reflex.estimateBackrunedExecuteGas(\n  executeParams,\n  backrunParams\n);\n```\n\n**Returns:** `bigint` - Estimated gas limit\n\n## \ud83d\udccb Contract Information\n\n### `getAdmin()`\n\nGets the current owner/admin of the Reflex Router.\n\n```typescript\nconst adminAddress = await reflex.getAdmin();\n```\n\n**Returns:** `string` - The address of the current admin\n\n## \ud83d\udcca Events & Monitoring\n\n### `watchBackrunExecuted()`\n\nListens for BackrunExecuted events from the contract.\n\n```typescript\nconst unsubscribe = reflex.watchBackrunExecuted(\n  (event) => {\n    console.log("Backrun executed:", {\n      triggerPoolId: event.triggerPoolId,\n      profit: event.profit,\n      profitToken: event.profitToken,\n      recipient: event.recipient,\n    });\n  },\n  {\n    triggerPoolId: "0x123...", // Optional filter\n    profitToken: "0x456...", // Optional filter\n    recipient: "0x789...", // Optional filter\n  }\n);\n\n// Unsubscribe when done\nunsubscribe();\n```\n\n**Event Structure:**\n\n```typescript\ninterface BackrunExecutedEvent {\n  triggerPoolId: string; // Pool ID that triggered the backrun\n  swapAmountIn: bigint; // Input swap amount\n  token0In: boolean; // Whether token0 was used as input\n  profit: bigint; // Profit amount generated\n  profitToken: string; // Token address in which profit was generated\n  recipient: string; // Address that received the profit\n}\n```\n\n## \ud83d\udd27 Utilities\n\n### `encodeBackrunedExecute()`\n\nEncodes function data for backruned execute (useful for batch transactions).\n\n```typescript\nconst encodedData = reflex.encodeBackrunedExecute(executeParams, backrunParams);\n```\n\n**Returns:** `string` - Encoded function data\n**Returns:** `string` - Encoded function data\n\n## \ud83e\uddf0 Utility Functions\n\n### Address Validation\n\n```typescript\nimport { isValidAddress, isValidBytes32 } from "@reflex-mev/sdk/utils";\n\n// Check if address is valid\nif (isValidAddress("0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3")) {\n  console.log("Valid address");\n}\n\n// Check if bytes32 value is valid (e.g., pool ID)\nif (isValidBytes32("0x1234567890abcdef...")) {\n  console.log("Valid bytes32");\n}\n```\n\n### Token Amount Formatting\n\n```typescript\nimport { formatTokenAmount, parseTokenAmount } from "@reflex/sdk/utils";\n\n// Format BigInt to human-readable string\nconst formatted = formatTokenAmount(\n  1500123456789012345678n, // BigInt value\n  18 // decimals\n); // "1500.123456789012345678"\n\n// Parse string to BigInt\nconst parsed = parseTokenAmount("1500.123456", 18);\n// Returns: 1500123456000000000000n\n```\n\n### Profit Calculations\n\n```typescript\nimport { calculateProfitPercentage } from "@reflex/sdk/utils";\n\n// Calculate profit percentage\nconst profitPercent = calculateProfitPercentage(\n  150000000000000000n, // 0.15 ETH profit\n  1000000000000000000n // 1 ETH investment\n); // Returns: 15 (15%)\n```\n\n## \u26a0\ufe0f Error Handling\n\n```typescript\ntry {\n  const result = await reflex.backrunedExecute(executeParams, backrunParams);\n\n  if (!result.success) {\n    console.error("Backrun execution failed");\n  } else {\n    console.log("Profits:", result.profits);\n  }\n} catch (error) {\n  console.error("SDK Error:", error.message);\n}\n```\n\n### Common Error Types\n\n| Error Type                 | Description                         | Solution                                     |\n| -------------------------- | ----------------------------------- | -------------------------------------------- |\n| `Gas estimation failed`    | Cannot estimate gas for transaction | Check parameters and network connection      |\n| `Transaction failed`       | Transaction reverted on-chain       | Verify contract state and parameters         |\n| `Backruned execute failed` | Execute + backrun operation failed  | Check target contract and backrun parameters |\n\n## \ud83d\udcdd TypeScript Types\n\n### Core Interfaces\n\n```typescript\n// Available imports\nimport {\n  ReflexSDK,\n  ExecuteParams,\n  BackrunParams,\n  BackrunedExecuteResult,\n  TransactionOptions,\n  BackrunExecutedEvent,\n} from "@reflex-mev/sdk";\n\n// Type definitions\ninterface ExecuteParams {\n  target: string;\n  value: bigint;\n  callData: BytesLike;\n}\n\ninterface BackrunParams {\n  triggerPoolId: string; // Pool ID that triggered the opportunity (bytes32)\n  swapAmountIn: BigNumberish; // Input swap amount\n  token0In: boolean; // Whether token0 is used as input\n  recipient: string; // Address to receive profits\n  configId?: string; // Optional: Configuration ID for profit splitting (bytes32)\n}\n\ninterface BackrunedExecuteResult {\n  success: boolean;\n  returnData: string;\n  profits: bigint[];\n  profitTokens: string[];\n  transactionHash: string;\n}\n\ninterface BackrunExecutedEvent {\n  triggerPoolId: string;\n  swapAmountIn: bigint;\n  token0In: boolean;\n  profit: bigint;\n  profitToken: string;\n  recipient: string;\n}\n```\n\n## \ud83d\udca1 Example Usage\n\n### Basic Backrun Execution\n\n```typescript\nimport { ReflexSDK } from "@reflex-mev/sdk";\nimport { ethers } from "ethers";\n\nasync function executeBackrun() {\n  const provider = new ethers.JsonRpcProvider(RPC_URL);\n  const signer = new ethers.Wallet(PRIVATE_KEY, provider);\n\n  const reflex = new ReflexSDK(\n    provider,\n    signer,\n    "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3" // Router address\n  );\n\n  // Prepare execute parameters (e.g., Uniswap swap)\n  const executeParams = {\n    target: "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", // Uniswap V2 Router\n    value: 0n,\n    callData: "0x...", // Encoded swap function call\n  };\n\n  // Prepare backrun parameters\n  const backrunParams = [\n    {\n      triggerPoolId: "0x1234...", // Pool that will be affected by the swap\n      swapAmountIn: ethers.parseEther("1"), // 1 ETH backrun\n      token0In: true,\n      recipient: await signer.getAddress(),\n      configId: "0x0000...", // Use default config\n    },\n  ];\n\n  try {\n    const result = await reflex.backrunedExecute(executeParams, backrunParams);\n\n    console.log("Transaction hash:", result.transactionHash);\n    console.log(\n      "Profits:",\n      result.profits.map((p) => ethers.formatEther(p))\n    );\n  } catch (error) {\n    console.error("Error:", error.message);\n  }\n}\n```\n\n### Event Monitoring\n\n```typescript\n// Monitor all backrun events\nconst unsubscribe = reflex.watchBackrunExecuted((event) => {\n  console.log(`Backrun executed on pool ${event.triggerPoolId}`);\n  console.log(\n    `Profit: ${ethers.formatEther(event.profit)} ${event.profitToken}`\n  );\n});\n\n// Monitor events for specific pool\nconst unsubscribePool = reflex.watchBackrunExecuted(\n  (event) => {\n    console.log("Our pool backrun:", event);\n  },\n  { triggerPoolId: "0x1234..." }\n);\n```\n\n---\n\n_For more detailed integration guidance, see our [Integration Guide](../integration/overview)._\n'})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}}}]);