"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[1878],{7207:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var r=i(4848),t=i(8453);const o={sidebar_position:2},l="Plugin-Based Integration",a={id:"integration/plugin-based",title:"Plugin-Based Integration",description:"Integrate Reflex MEV capture into DEXes with hook/plugin support using lightweight plugin contracts.",source:"@site/docs/integration/plugin-based.md",sourceDirName:"integration",slug:"/integration/plugin-based",permalink:"/integration/plugin-based",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/integration/plugin-based.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Integration Overview",permalink:"/integration/overview"},next:{title:"Universal DEX Integration",permalink:"/integration/universal-dex"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Implementation",id:"implementation",level:2},{value:"1. Algebra-Based Plugin",id:"1-algebra-based-plugin",level:3},{value:"2. PancakeSwap Infinity Plugin",id:"2-pancakeswap-infinity-plugin",level:3},{value:"3. Uniswap V4 Hook",id:"3-uniswap-v4-hook",level:3},{value:"Configuration",id:"configuration",level:2},{value:"Register Plugin with Pool",id:"register-plugin-with-pool",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Monitoring",id:"1-monitoring",level:3},{value:"2. Testing",id:"2-testing",level:3},{value:"3. Security",id:"3-security",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Plugin Not Triggering",id:"plugin-not-triggering",level:3},{value:"Failed Backruns",id:"failed-backruns",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"plugin-based-integration",children:"Plugin-Based Integration"})}),"\n",(0,r.jsx)(n.p,{children:"Integrate Reflex MEV capture into DEXes with hook/plugin support using lightweight plugin contracts."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Plugin-based integration is ideal for existing DEX protocols that support hooks or callbacks (like ",(0,r.jsx)(n.code,{children:"afterSwap"}),"). A lightweight plugin contract automatically triggers MEV capture after user swaps without requiring modifications to your core DEX contracts."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Best for:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Algebra, PancakeSwap Infinity, Uniswap v4 architectures"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Existing DEX protocols with plugin/hook systems"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Minimal code changes required"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Automatic MEV capture and distribution"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant User\n    participant Pool as DEX Pool\n    participant Plugin as Reflex Plugin\n    participant Router as Reflex Router\n\n    User->>Pool: Execute Swap\n    Pool->>Pool: Process swap\n    Pool->>Plugin: afterSwap() callback\n    Plugin->>Plugin: Check profitability threshold\n    Plugin->>Router: triggerBackrun()\n    Router->>Router: Capture MEV & distribute profits\n    Router--\x3e>User: MEV profits"}),"\n",(0,r.jsx)(n.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zero DEX Modifications"}),": Plugin sits alongside your existing pool contracts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Triggering"}),": Every swap is analyzed for MEV opportunities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configurable Thresholds"}),": Set minimum swap sizes and backrun ratios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Failsafe Design"}),": Failed MEV attempts don't affect user swaps"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"1-algebra-based-plugin",children:"1. Algebra-Based Plugin"}),"\n",(0,r.jsx)(n.p,{children:"For Algebra Integral pools:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract AlgebraReflexPlugin is ReflexAfterSwap {\n    address public immutable pool;\n\n    constructor(\n        address _reflexRouter,\n        address _pool,\n        bytes32 _configId\n    ) ReflexAfterSwap(_reflexRouter, _configId) {\n        pool = _pool;\n    }\n\n    function afterSwap(\n        address sender,\n        int256 amount0,\n        int256 amount1,\n        uint160 currentPrice,\n        uint128 currentLiquidity,\n        int24 currentTick,\n        bytes calldata data\n    ) external {\n        require(msg.sender == pool, "Only pool can call");\n        \n        // Use the base contract\'s _reflexAfterSwap function\n        _reflexAfterSwap(\n            bytes32(uint256(uint160(pool))), // triggerPoolId\n            amount0,                          // amount0Delta\n            amount1,                          // amount1Delta\n            amount0 > 0,                      // zeroForOne\n            sender                            // recipient\n        );\n    }\n\n    function _onlyReflexAdmin() internal view override {\n        // Implement admin access control\n        // Example: require(msg.sender == admin, "Only admin");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-pancakeswap-infinity-plugin",children:"2. PancakeSwap Infinity Plugin"}),"\n",(0,r.jsx)(n.p,{children:"For PancakeSwap Infinity pools (uses Algebra-based architecture):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract PancakeSwapInfinityReflexPlugin is ReflexAfterSwap {\n    address public immutable pool;\n\n    constructor(\n        address _reflexRouter,\n        address _pool,\n        bytes32 _configId\n    ) ReflexAfterSwap(_reflexRouter, _configId) {\n        pool = _pool;\n    }\n\n    function afterSwap(\n        address sender,\n        int256 amount0,\n        int256 amount1,\n        uint160 currentPrice,\n        uint128 currentLiquidity,\n        int24 currentTick,\n        bytes calldata data\n    ) external {\n        require(msg.sender == pool, "Only pool can call");\n        \n        // Use the base contract\'s _reflexAfterSwap function\n        _reflexAfterSwap(\n            bytes32(uint256(uint160(pool))), // triggerPoolId\n            amount0,                          // amount0Delta\n            amount1,                          // amount1Delta\n            amount0 > 0,                      // zeroForOne\n            sender                            // recipient\n        );\n    }\n\n    function _onlyReflexAdmin() internal view override {\n        // Implement admin access control\n        // Example: require(msg.sender == admin, "Only admin");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-uniswap-v4-hook",children:"3. Uniswap V4 Hook"}),"\n",(0,r.jsx)(n.p,{children:"For Uniswap V4 pools:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport {BaseHook} from "v4-periphery/BaseHook.sol";\nimport {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";\nimport {PoolKey} from "v4-core/types/PoolKey.sol";\nimport {BalanceDelta} from "v4-core/types/BalanceDelta.sol";\nimport {Hooks} from "v4-core/libraries/Hooks.sol";\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract UniswapV4ReflexHook is BaseHook, ReflexAfterSwap {\n    constructor(\n        IPoolManager _poolManager,\n        address _reflexRouter,\n        bytes32 _configId\n    ) BaseHook(_poolManager) ReflexAfterSwap(_reflexRouter, _configId) {}\n\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external override returns (bytes4) {\n        // Use the base contract\'s _reflexAfterSwap function\n        _reflexAfterSwap(\n            keccak256(abi.encode(key)),      // triggerPoolId\n            delta.amount0(),                  // amount0Delta\n            delta.amount1(),                  // amount1Delta\n            params.zeroForOne,                // zeroForOne\n            sender                            // recipient\n        );\n\n        return BaseHook.afterSwap.selector;\n    }\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: false,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false\n        });\n    }\n\n    function _onlyReflexAdmin() internal view override {\n        // Implement admin access control\n        // Example: require(msg.sender == admin, "Only admin");\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsx)(n.h3,{id:"register-plugin-with-pool",children:"Register Plugin with Pool"}),"\n",(0,r.jsx)(n.p,{children:"For Algebra pools:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"// As pool owner/admin\npool.setPlugin(pluginAddress);\n"})}),"\n",(0,r.jsx)(n.p,{children:"For Uniswap V4:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"// Deploy with hook address in pool key\nPoolKey memory key = PoolKey({\n    currency0: currency0,\n    currency1: currency1,\n    fee: fee,\n    tickSpacing: tickSpacing,\n    hooks: IHooks(hookAddress)\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-monitoring",children:"1. Monitoring"}),"\n",(0,r.jsx)(n.p,{children:"Listen for MEV capture events from the ReflexRouter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"// Listen to BackrunExecuted event from ReflexRouter\nevent BackrunExecuted(\n    bytes32 indexed poolId,\n    address indexed user,\n    uint256 profit,\n    address profitToken,\n    bytes32 indexed configId\n);\n"})}),"\n",(0,r.jsx)(n.p,{children:"You can filter these events by your pool ID or config ID to monitor MEV captures for your integration."}),"\n",(0,r.jsx)(n.h3,{id:"2-testing",children:"2. Testing"}),"\n",(0,r.jsx)(n.p,{children:"Always test your plugin integration thoroughly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"// Test small swaps\n// Test large swaps\n// Test failsafe behavior\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-security",children:"3. Security"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"try/catch"})," to prevent plugin failures from affecting swaps"]}),"\n",(0,r.jsx)(n.li,{children:"Implement proper access controls for admin functions"}),"\n",(0,r.jsx)(n.li,{children:"Monitor plugin behavior and adjust as needed"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,r.jsx)(n.h3,{id:"plugin-not-triggering",children:"Plugin Not Triggering"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Verify plugin is registered with the pool"}),"\n",(0,r.jsx)(n.li,{children:"Check that swaps are being executed through the pool"}),"\n",(0,r.jsxs)(n.li,{children:["Verify the plugin's ",(0,r.jsx)(n.code,{children:"afterSwap"})," hook is being called"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"failed-backruns",children:"Failed Backruns"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Check gas limits are sufficient"}),"\n",(0,r.jsx)(n.li,{children:"Review event logs for failure reasons"}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Next Steps:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../api/reflex-router",children:"View API Reference"})," - Complete contract documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"../architecture",children:"Read Architecture Guide"})," - Understand the system design"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"./overview",children:"Explore Other Integration Methods"})," - Compare integration options"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);