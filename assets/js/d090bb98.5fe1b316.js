"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[655],{5444:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=t(4848),r=t(8453);const o={sidebar_position:2},a="Smart Contract Integration",s={id:"technical/integration/smart-contract",title:"Smart Contract Integration",description:"Integrate Reflex MEV capture directly into your smart contracts using either router direct access or plugin-based architecture.",source:"@site/docs/technical/integration/smart-contract.md",sourceDirName:"technical/integration",slug:"/technical/integration/smart-contract",permalink:"/reflex/technical/integration/smart-contract",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/technical/integration/smart-contract.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Integration Overview",permalink:"/reflex/technical/integration/overview"},next:{title:"SDK Integration",permalink:"/reflex/technical/integration/sdk-integration"}},l={},c=[{value:"Router Direct Access",id:"router-direct-access",level:2},{value:"Overview",id:"overview",level:3},{value:"Implementation",id:"implementation",level:3},{value:"1. Import Reflex Interface",id:"1-import-reflex-interface",level:4},{value:"2. Trigger Backruns",id:"2-trigger-backruns",level:4},{value:"3. Revenue Configuration",id:"3-revenue-configuration",level:4},{value:"Plugin-Based Access",id:"plugin-based-access",level:2},{value:"Overview",id:"overview-1",level:3},{value:"UniswapV2-Style Plugin",id:"uniswapv2-style-plugin",level:3},{value:"UniswapV3-Style Plugin",id:"uniswapv3-style-plugin",level:3},{value:"Integration with Existing Pools",id:"integration-with-existing-pools",level:3},{value:"Modify Pool Contract",id:"modify-pool-contract",level:4},{value:"Factory Integration",id:"factory-integration",level:4},{value:"Deployment Guide",id:"deployment-guide",level:2},{value:"1. Deploy Plugin Contract",id:"1-deploy-plugin-contract",level:3},{value:"2. Configure Revenue Sharing",id:"2-configure-revenue-sharing",level:3},{value:"3. Integration Testing",id:"3-integration-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Security Considerations",id:"security-considerations",level:3},{value:"Gas Optimization",id:"gas-optimization",level:3},{value:"Monitoring",id:"monitoring",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"smart-contract-integration",children:"Smart Contract Integration"})}),"\n",(0,i.jsx)(e.p,{children:"Integrate Reflex MEV capture directly into your smart contracts using either router direct access or plugin-based architecture."}),"\n",(0,i.jsx)(e.h2,{id:"router-direct-access",children:"Router Direct Access"}),"\n",(0,i.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Direct integration with the Reflex Router gives you complete control over MEV capture timing and logic. This approach is ideal for new protocols or when you want tight integration with your core contract logic."}),"\n",(0,i.jsx)(e.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(e.h4,{id:"1-import-reflex-interface",children:"1. Import Reflex Interface"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/interfaces/IReflexRouter.sol";\n\ncontract YourProtocol {\n    IReflexRouter public immutable reflexRouter;\n    \n    constructor(address _reflexRouter) {\n        reflexRouter = IReflexRouter(_reflexRouter);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"2-trigger-backruns",children:"2. Trigger Backruns"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:"function executeSwapWithMEV(\n    address tokenIn,\n    address tokenOut,\n    uint256 amountIn,\n    bytes32 configId\n) external {\n    // Execute your core swap logic\n    uint256 amountOut = _executeSwap(tokenIn, tokenOut, amountIn);\n    \n    // Trigger MEV capture\n    try reflexRouter.triggerBackrun(\n        bytes32(uint256(uint160(address(this)))), // Pool identifier\n        uint112(amountIn / 20), // 5% of swap for backrun\n        tokenIn < tokenOut, // Token order\n        msg.sender, // Profit recipient\n        configId // Revenue sharing config\n    ) returns (uint256 profit, address profitToken) {\n        emit MEVCaptured(msg.sender, profit, profitToken);\n    } catch {\n        // MEV capture failed, continue normal operation\n        emit MEVCaptureFailed(msg.sender, amountIn);\n    }\n}\n"})}),"\n",(0,i.jsx)(e.h4,{id:"3-revenue-configuration",children:"3. Revenue Configuration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'function setupRevenueSharing() external onlyOwner {\n    bytes32 configId = keccak256("YOUR_PROTOCOL_CONFIG");\n    \n    address[] memory recipients = new address[](3);\n    recipients[0] = protocolTreasury;\n    recipients[1] = userRewardsPool;\n    recipients[2] = validatorTips;\n    \n    uint256[] memory shares = new uint256[](3);\n    shares[0] = 40; // 40% to protocol\n    shares[1] = 50; // 50% to users\n    shares[2] = 10; // 10% to validators\n    \n    reflexRouter.configureRevenue(configId, recipients, shares);\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"plugin-based-access",children:"Plugin-Based Access"}),"\n",(0,i.jsx)(e.h3,{id:"overview-1",children:"Overview"}),"\n",(0,i.jsx)(e.p,{children:"Plugin-based integration uses lightweight contracts that hook into your existing DEX architecture. This is perfect for protocols that already have callback systems or want minimal changes to existing code."}),"\n",(0,i.jsx)(e.h3,{id:"uniswapv2-style-plugin",children:"UniswapV2-Style Plugin"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract UniV2ReflexPlugin is ReflexAfterSwap {\n    uint256 public constant MIN_THRESHOLD = 1e18;\n    bytes32 public immutable CONFIG_ID;\n    \n    constructor(\n        address _reflexRouter,\n        address _pool,\n        bytes32 _configId\n    ) ReflexAfterSwap(_reflexRouter, _pool) {\n        CONFIG_ID = _configId;\n    }\n    \n    function afterSwap(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override onlyPool {\n        uint256 swapAmount = amount0 > 0 ? amount0 : amount1;\n        \n        if (swapAmount >= MIN_THRESHOLD) {\n            reflexRouter.triggerBackrun(\n                bytes32(uint256(uint160(pool))),\n                uint112(swapAmount / 20), // 5% of swap\n                amount0 > 0,\n                sender,\n                CONFIG_ID\n            );\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"uniswapv3-style-plugin",children:"UniswapV3-Style Plugin"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'pragma solidity ^0.8.19;\n\nimport "@reflex/contracts/ReflexAfterSwap.sol";\n\ncontract UniV3ReflexPlugin is ReflexAfterSwap {\n    struct PluginConfig {\n        uint256 minThreshold;\n        uint256 backrunRatio; // Basis points\n        bool enabled;\n        mapping(address => bool) excludedUsers;\n    }\n    \n    PluginConfig public config;\n    \n    constructor(\n        address _reflexRouter,\n        address _pool\n    ) ReflexAfterSwap(_reflexRouter, _pool) {\n        config.minThreshold = 1e18;\n        config.backrunRatio = 500; // 5%\n        config.enabled = true;\n    }\n    \n    function afterSwap(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override onlyPool {\n        if (!config.enabled || config.excludedUsers[sender]) {\n            return;\n        }\n        \n        uint256 swapAmount = amount0 > 0 ? amount0 : amount1;\n        \n        if (swapAmount >= config.minThreshold) {\n            uint256 backrunAmount = (swapAmount * config.backrunRatio) / 10000;\n            \n            reflexRouter.triggerBackrun(\n                bytes32(uint256(uint160(pool))),\n                uint112(backrunAmount),\n                amount0 > 0,\n                sender,\n                bytes32(0) // Use default config\n            );\n        }\n    }\n    \n    // Admin functions\n    function updateConfig(\n        uint256 _minThreshold,\n        uint256 _backrunRatio,\n        bool _enabled\n    ) external onlyOwner {\n        config.minThreshold = _minThreshold;\n        config.backrunRatio = _backrunRatio;\n        config.enabled = _enabled;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"integration-with-existing-pools",children:"Integration with Existing Pools"}),"\n",(0,i.jsx)(e.h4,{id:"modify-pool-contract",children:"Modify Pool Contract"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'contract YourPool {\n    address public reflexPlugin;\n    \n    modifier withMEVCapture() {\n        _;\n        if (reflexPlugin != address(0)) {\n            try IReflexPlugin(reflexPlugin).afterSwap(\n                msg.sender,\n                amount0Out,\n                amount1Out,\n                ""\n            ) {} catch {\n                // Plugin failed, continue normal operation\n            }\n        }\n    }\n    \n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external withMEVCapture {\n        // Your existing swap logic\n        _swap(amount0Out, amount1Out, to, data);\n    }\n    \n    function setReflexPlugin(address _plugin) external onlyOwner {\n        reflexPlugin = _plugin;\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h4,{id:"factory-integration",children:"Factory Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'contract YourPoolFactory {\n    address public immutable reflexRouter;\n    mapping(address => address) public poolPlugins;\n    \n    constructor(address _reflexRouter) {\n        reflexRouter = _reflexRouter;\n    }\n    \n    function createPoolWithMEV(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool, address plugin) {\n        // Create pool\n        pool = _createPool(tokenA, tokenB, fee);\n        \n        // Deploy plugin\n        plugin = new UniV2ReflexPlugin(\n            reflexRouter,\n            pool,\n            keccak256(abi.encodePacked("POOL_", pool))\n        );\n        \n        // Configure pool to use plugin\n        IYourPool(pool).setReflexPlugin(plugin);\n        \n        poolPlugins[pool] = plugin;\n        \n        emit PoolCreatedWithMEV(pool, plugin);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"deployment-guide",children:"Deployment Guide"}),"\n",(0,i.jsx)(e.h3,{id:"1-deploy-plugin-contract",children:"1. Deploy Plugin Contract"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// deploy-plugin.ts\nimport { ethers } from "hardhat";\n\nasync function deployPlugin() {\n    const [deployer] = await ethers.getSigners();\n    \n    const Plugin = await ethers.getContractFactory("UniV2ReflexPlugin");\n    const plugin = await Plugin.deploy(\n        "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3", // Reflex Router\n        "0xYourPoolAddress",\n        ethers.id("YOUR_CONFIG_ID")\n    );\n    \n    await plugin.waitForDeployment();\n    \n    console.log("Plugin deployed to:", await plugin.getAddress());\n    return plugin;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"2-configure-revenue-sharing",children:"2. Configure Revenue Sharing"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-typescript",children:'// configure-revenue.ts\nasync function configureRevenue() {\n    const reflexRouter = await ethers.getContractAt(\n        "ReflexRouter",\n        "0x742d35Cc6634C0532925a3b8D598C4B4B3A3A3A3"\n    );\n    \n    const configId = ethers.id("YOUR_CONFIG_ID");\n    const recipients = [\n        "0xProtocolTreasury",\n        "0xUserRewards",\n        "0xValidatorTips"\n    ];\n    const shares = [40, 50, 10]; // Percentages\n    \n    await reflexRouter.configureRevenue(configId, recipients, shares);\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"3-integration-testing",children:"3. Integration Testing"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-solidity",children:'// Test your integration\ncontract PluginIntegrationTest {\n    function testMEVCapture() public {\n        // 1. Execute a large swap\n        pool.swap(largeAmount, 0, user, "");\n        \n        // 2. Verify plugin was triggered\n        assertEq(plugin.lastTriggerBlock(), block.number);\n        \n        // 3. Check profit distribution\n        uint256 userBalance = token.balanceOf(user);\n        assertGt(userBalance, initialBalance);\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.h3,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Always use try/catch"})," when calling Reflex functions"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Validate all inputs"})," before triggering MEV capture"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Set reasonable thresholds"})," to prevent spam"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement access controls"})," for configuration functions"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"gas-optimization",children:"Gas Optimization"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cache frequently used values"})," like config IDs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use appropriate data types"})," (uint112 for amounts)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Minimize external calls"})," in hot paths"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider batch operations"})," for multiple triggers"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"monitoring",children:"Monitoring"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Emit events"})," for all MEV capture attempts"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Track success/failure rates"})," in your analytics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monitor gas usage"})," patterns"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Set up alerts"})," for unusual activity"]}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:["For SDK integration, see the ",(0,i.jsx)(e.a,{href:"./sdk-integration",children:"SDK Integration Guide"}),".\nFor detailed examples, check out the ",(0,i.jsx)(e.a,{href:"../examples/basic-backrun",children:"Basic Backrun Example"}),"."]})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}}}]);