"use strict";(self.webpackChunkreflex_docs=self.webpackChunkreflex_docs||[]).push([[3361],{8321:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var t=r(4848),s=r(8453);const i={sidebar_position:0,slug:"/"},l="Overview",o={id:"index",title:"Overview",description:"Introduction",source:"@site/docs/index.md",sourceDirName:".",slug:"/",permalink:"/reflex/",draft:!1,unlisted:!1,editUrl:"https://github.com/reflex-mev/reflex/tree/main/website/docs/index.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,slug:"/"},sidebar:"tutorialSidebar",next:{title:"Architecture",permalink:"/reflex/architecture"}},a={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Why Reflex is built for flow owners",id:"why-reflex-is-built-for-flow-owners",level:2},{value:"Who can integrate Reflex?",id:"who-can-integrate-reflex",level:2},{value:"Reflex vs External Arbitrage",id:"reflex-vs-external-arbitrage",level:2},{value:"Why this matters \u2014 for DEXes, aggregators, RFQ engines, and execution layers",id:"why-this-matters--for-dexes-aggregators-rfq-engines-and-execution-layers",level:2},{value:"Integration Types",id:"integration-types",level:2},{value:"Supported Protocols",id:"supported-protocols",level:3},{value:"Getting Started",id:"getting-started",level:3},{value:"Technical Documentation",id:"technical-documentation",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const n={a:"a",br:"br",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Reflex is an on-chain MEV capture engine built for any product or protocol that controls trading flow."}),"\n",(0,t.jsx)(n.p,{children:"If you operate a DEX, an aggregator, an RFQ system, or a smart order router \u2014 your flow creates arbitrage opportunities. Today, that arbitrage is captured by external bots and leaves your ecosystem."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Reflex changes the economics:"})}),"\n",(0,t.jsx)(n.p,{children:"It captures the same arbitrage inside the user transaction itself and routes the profits back to the flow owner \u2014 or to LPs, users, or your treasury, based on your configuration."}),"\n",(0,t.jsx)(n.p,{children:"Reflex also neutralizes toxic MEV such as sandwich attacks, converting harmful extraction into aligned, value-creating execution."}),"\n",(0,t.jsx)(n.h2,{id:"why-reflex-is-built-for-flow-owners",children:"Why Reflex is built for flow owners"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fully on-chain"})," \u2014 all computation and backrun execution happen directly on-chain, with no backend, no relayers, no off-chain solvers."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Plug-and-play integration"})," \u2014 works with leading DEXes and aggregators without requiring changes to your architecture."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Non-custodial"})," \u2014 Reflex never takes custody, never requires approvals, and cannot touch user funds."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Universal compatibility"})," \u2014 supports any trading flow that creates price impact and arbitrage."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Deterministic execution"})," \u2014 MEV capture occurs atomically inside the same transaction."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"MEV protection"})," \u2014 Reflex absorbs sandwich attempts by converting the attacker's opportunity into internal arbitrage that benefits your ecosystem."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"who-can-integrate-reflex",children:"Who can integrate Reflex?"}),"\n",(0,t.jsx)(n.p,{children:"Reflex is built for any execution layer that creates or routes swaps, including:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"DEX protocols"})," \u2014 supporting all major AMM models and their routing layers"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Aggregators and Smart Order Routers"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"RFQ engines"})," that settle on-chain"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Cross-chain routers"})," and bridge-based swap flows"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"L1/L2 native AMM modules"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If your system creates token price movement, Reflex allows you to reclaim the value that movement generates."}),"\n",(0,t.jsx)(n.h2,{id:"reflex-vs-external-arbitrage",children:"Reflex vs External Arbitrage"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{}),(0,t.jsx)(n.th,{children:"External Arbitrage (today)"}),(0,t.jsx)(n.th,{children:"Reflex (integrated)"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"MEV profits"})}),(0,t.jsx)(n.td,{children:"Taken by searchers, leaving the ecosystem"}),(0,t.jsx)(n.td,{children:"Captured and redistributed to the flow owner"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Ecosystem value"})}),(0,t.jsx)(n.td,{children:"Lost"}),(0,t.jsx)(n.td,{children:"Routed to LPs, users, or the treasury"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Execution path"})}),(0,t.jsx)(n.td,{children:"Off-chain, opaque, unpredictable"}),(0,t.jsx)(n.td,{children:"Native, deterministic, within the same transaction"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Control"})}),(0,t.jsx)(n.td,{children:"None"}),(0,t.jsx)(n.td,{children:"Full control over profit routing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Alignment"})}),(0,t.jsx)(n.td,{children:"Zero alignment"}),(0,t.jsx)(n.td,{children:"100% aligned with protocol incentives"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Sandwich attacks"})}),(0,t.jsx)(n.td,{children:"Harmful, extractive, user-hostile"}),(0,t.jsx)(n.td,{children:"Neutralized \u2014 Reflex converts toxic MEV into positive MEV"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"why-this-matters--for-dexes-aggregators-rfq-engines-and-execution-layers",children:"Why this matters \u2014 for DEXes, aggregators, RFQ engines, and execution layers"}),"\n",(0,t.jsxs)(n.p,{children:["Every swap you route creates price shifts.",(0,t.jsx)(n.br,{}),"\n","Price shifts create arbitrage.",(0,t.jsx)(n.br,{}),"\n","Arbitrage creates profit."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"If you do nothing, that profit is taken by outsiders."})}),"\n",(0,t.jsx)(n.p,{children:"With Reflex, you internalize that value and turn it into a native revenue engine that strengthens your product, your users, and your ecosystem \u2014 while eliminating toxic MEV."}),"\n",(0,t.jsx)(n.p,{children:"Reflex ensures you keep the value your flow creates."}),"\n",(0,t.jsx)(n.h2,{id:"integration-types",children:"Integration Types"}),"\n",(0,t.jsx)(n.p,{children:"Reflex offers three primary integration methods to suit different protocol architectures and use cases:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/plugin-based",children:"DEX Plugin-Based Integration"})})," - For DEXes with hook/plugin support (Algebra, PancakeSwap Infinity, Uniswap v4)"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/universal-dex",children:"Universal DEX Integration"})})," - For any DEX and client-side applications using SwapProxy + SDK"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/direct-access",children:"Direct Contract Access"})})," - For custom smart contract integration with full control"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"supported-protocols",children:"Supported Protocols"}),"\n",(0,t.jsx)(n.p,{children:"Reflex is protocol-agnostic and already runs with leading DEXs and aggregators across EVM ecosystem."}),"\n",(0,t.jsx)(n.h3,{id:"getting-started",children:"Getting Started"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Contact us to request an API key."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Configure payout addresses."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Plug and play integration (hook, router, sdk)."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Start capturing MEV profits immediately."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"technical-documentation",children:"Technical Documentation"}),"\n",(0,t.jsx)(n.p,{children:"Ready to integrate Reflex into your protocol? Check out our comprehensive guides:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\ufffd ",(0,t.jsx)(n.a,{href:"./integration/overview",children:(0,t.jsx)(n.strong,{children:"Integration Guide"})})," - Step-by-step integration instructions"]}),"\n",(0,t.jsxs)(n.li,{children:["\ufffd ",(0,t.jsx)(n.a,{href:"./api/reflex-router",children:(0,t.jsx)(n.strong,{children:"API Reference"})})," - Complete contract documentation"]}),"\n",(0,t.jsxs)(n.li,{children:["\ud83c\udfd7\ufe0f ",(0,t.jsx)(n.a,{href:"./architecture",children:(0,t.jsx)(n.strong,{children:"Architecture"})})," - Understand the system design"]}),"\n",(0,t.jsxs)(n.li,{children:["\ufffd ",(0,t.jsx)(n.a,{href:"/reflex/security/overview",children:(0,t.jsx)(n.strong,{children:"Security"})})," - Security considerations and best practices"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/overview",children:"Start with Integration"})})," - Learn how to integrate Reflex"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./architecture",children:"Read the Architecture"})})," - Understand the system design"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/plugin-based",children:"Plugin-Based Integration"})})," - For DEXes with hook support"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/universal-dex",children:"Universal DEX Integration"})})," - For any DEX or DApp"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"./integration/direct-access",children:"Direct Contract Access"})})," - For custom protocols"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Ready to revolutionize MEV capture? Let's get started ! \ud83d\ude80"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);